/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const IPCRequests = $root.IPCRequests = (() => {

    /**
     * Properties of a IPCRequests.
     * @exports IIPCRequests
     * @interface IIPCRequests
     * @property {IPopupRequest|null} [popupRequest] IPCRequests popupRequest
     * @property {IInputRequest|null} [inputRequest] IPCRequests inputRequest
     * @property {IShutdownRequest|null} [shutdownRequest] IPCRequests shutdownRequest
     */

    /**
     * Constructs a new IPCRequests.
     * @exports IPCRequests
     * @classdesc Represents a IPCRequests.
     * @implements IIPCRequests
     * @constructor
     * @param {IIPCRequests=} [properties] Properties to set
     */
    function IPCRequests(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * IPCRequests popupRequest.
     * @member {IPopupRequest|null|undefined} popupRequest
     * @memberof IPCRequests
     * @instance
     */
    IPCRequests.prototype.popupRequest = null;

    /**
     * IPCRequests inputRequest.
     * @member {IInputRequest|null|undefined} inputRequest
     * @memberof IPCRequests
     * @instance
     */
    IPCRequests.prototype.inputRequest = null;

    /**
     * IPCRequests shutdownRequest.
     * @member {IShutdownRequest|null|undefined} shutdownRequest
     * @memberof IPCRequests
     * @instance
     */
    IPCRequests.prototype.shutdownRequest = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * IPCRequests message.
     * @member {"popupRequest"|"inputRequest"|"shutdownRequest"|undefined} message
     * @memberof IPCRequests
     * @instance
     */
    Object.defineProperty(IPCRequests.prototype, "message", {
        get: $util.oneOfGetter($oneOfFields = ["popupRequest", "inputRequest", "shutdownRequest"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new IPCRequests instance using the specified properties.
     * @function create
     * @memberof IPCRequests
     * @static
     * @param {IIPCRequests=} [properties] Properties to set
     * @returns {IPCRequests} IPCRequests instance
     */
    IPCRequests.create = function create(properties) {
        return new IPCRequests(properties);
    };

    /**
     * Encodes the specified IPCRequests message. Does not implicitly {@link IPCRequests.verify|verify} messages.
     * @function encode
     * @memberof IPCRequests
     * @static
     * @param {IIPCRequests} message IPCRequests message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    IPCRequests.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.popupRequest != null && Object.hasOwnProperty.call(message, "popupRequest"))
            $root.PopupRequest.encode(message.popupRequest, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.inputRequest != null && Object.hasOwnProperty.call(message, "inputRequest"))
            $root.InputRequest.encode(message.inputRequest, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.shutdownRequest != null && Object.hasOwnProperty.call(message, "shutdownRequest"))
            $root.ShutdownRequest.encode(message.shutdownRequest, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified IPCRequests message, length delimited. Does not implicitly {@link IPCRequests.verify|verify} messages.
     * @function encodeDelimited
     * @memberof IPCRequests
     * @static
     * @param {IIPCRequests} message IPCRequests message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    IPCRequests.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a IPCRequests message from the specified reader or buffer.
     * @function decode
     * @memberof IPCRequests
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {IPCRequests} IPCRequests
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    IPCRequests.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.IPCRequests();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.popupRequest = $root.PopupRequest.decode(reader, reader.uint32());
                    break;
                }
            case 2: {
                    message.inputRequest = $root.InputRequest.decode(reader, reader.uint32());
                    break;
                }
            case 3: {
                    message.shutdownRequest = $root.ShutdownRequest.decode(reader, reader.uint32());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a IPCRequests message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof IPCRequests
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {IPCRequests} IPCRequests
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    IPCRequests.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a IPCRequests message.
     * @function verify
     * @memberof IPCRequests
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    IPCRequests.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.popupRequest != null && message.hasOwnProperty("popupRequest")) {
            properties.message = 1;
            {
                let error = $root.PopupRequest.verify(message.popupRequest);
                if (error)
                    return "popupRequest." + error;
            }
        }
        if (message.inputRequest != null && message.hasOwnProperty("inputRequest")) {
            if (properties.message === 1)
                return "message: multiple values";
            properties.message = 1;
            {
                let error = $root.InputRequest.verify(message.inputRequest);
                if (error)
                    return "inputRequest." + error;
            }
        }
        if (message.shutdownRequest != null && message.hasOwnProperty("shutdownRequest")) {
            if (properties.message === 1)
                return "message: multiple values";
            properties.message = 1;
            {
                let error = $root.ShutdownRequest.verify(message.shutdownRequest);
                if (error)
                    return "shutdownRequest." + error;
            }
        }
        return null;
    };

    /**
     * Creates a IPCRequests message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof IPCRequests
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {IPCRequests} IPCRequests
     */
    IPCRequests.fromObject = function fromObject(object) {
        if (object instanceof $root.IPCRequests)
            return object;
        let message = new $root.IPCRequests();
        if (object.popupRequest != null) {
            if (typeof object.popupRequest !== "object")
                throw TypeError(".IPCRequests.popupRequest: object expected");
            message.popupRequest = $root.PopupRequest.fromObject(object.popupRequest);
        }
        if (object.inputRequest != null) {
            if (typeof object.inputRequest !== "object")
                throw TypeError(".IPCRequests.inputRequest: object expected");
            message.inputRequest = $root.InputRequest.fromObject(object.inputRequest);
        }
        if (object.shutdownRequest != null) {
            if (typeof object.shutdownRequest !== "object")
                throw TypeError(".IPCRequests.shutdownRequest: object expected");
            message.shutdownRequest = $root.ShutdownRequest.fromObject(object.shutdownRequest);
        }
        return message;
    };

    /**
     * Creates a plain object from a IPCRequests message. Also converts values to other types if specified.
     * @function toObject
     * @memberof IPCRequests
     * @static
     * @param {IPCRequests} message IPCRequests
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    IPCRequests.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (message.popupRequest != null && message.hasOwnProperty("popupRequest")) {
            object.popupRequest = $root.PopupRequest.toObject(message.popupRequest, options);
            if (options.oneofs)
                object.message = "popupRequest";
        }
        if (message.inputRequest != null && message.hasOwnProperty("inputRequest")) {
            object.inputRequest = $root.InputRequest.toObject(message.inputRequest, options);
            if (options.oneofs)
                object.message = "inputRequest";
        }
        if (message.shutdownRequest != null && message.hasOwnProperty("shutdownRequest")) {
            object.shutdownRequest = $root.ShutdownRequest.toObject(message.shutdownRequest, options);
            if (options.oneofs)
                object.message = "shutdownRequest";
        }
        return object;
    };

    /**
     * Converts this IPCRequests to JSON.
     * @function toJSON
     * @memberof IPCRequests
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    IPCRequests.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for IPCRequests
     * @function getTypeUrl
     * @memberof IPCRequests
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    IPCRequests.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/IPCRequests";
    };

    return IPCRequests;
})();

export const PopupRequest = $root.PopupRequest = (() => {

    /**
     * Properties of a PopupRequest.
     * @exports IPopupRequest
     * @interface IPopupRequest
     * @property {string|null} [URL] PopupRequest URL
     * @property {string|null} [ClientID] PopupRequest ClientID
     * @property {string|null} [AppName] PopupRequest AppName
     * @property {string|null} [Favicon] PopupRequest Favicon
     * @property {string|null} [Title] PopupRequest Title
     * @property {boolean|null} [AutoAuthorize] PopupRequest AutoAuthorize
     * @property {string|null} [requestID] PopupRequest requestID
     */

    /**
     * Constructs a new PopupRequest.
     * @exports PopupRequest
     * @classdesc Represents a PopupRequest.
     * @implements IPopupRequest
     * @constructor
     * @param {IPopupRequest=} [properties] Properties to set
     */
    function PopupRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PopupRequest URL.
     * @member {string} URL
     * @memberof PopupRequest
     * @instance
     */
    PopupRequest.prototype.URL = "";

    /**
     * PopupRequest ClientID.
     * @member {string} ClientID
     * @memberof PopupRequest
     * @instance
     */
    PopupRequest.prototype.ClientID = "";

    /**
     * PopupRequest AppName.
     * @member {string} AppName
     * @memberof PopupRequest
     * @instance
     */
    PopupRequest.prototype.AppName = "";

    /**
     * PopupRequest Favicon.
     * @member {string} Favicon
     * @memberof PopupRequest
     * @instance
     */
    PopupRequest.prototype.Favicon = "";

    /**
     * PopupRequest Title.
     * @member {string} Title
     * @memberof PopupRequest
     * @instance
     */
    PopupRequest.prototype.Title = "";

    /**
     * PopupRequest AutoAuthorize.
     * @member {boolean} AutoAuthorize
     * @memberof PopupRequest
     * @instance
     */
    PopupRequest.prototype.AutoAuthorize = false;

    /**
     * PopupRequest requestID.
     * @member {string} requestID
     * @memberof PopupRequest
     * @instance
     */
    PopupRequest.prototype.requestID = "";

    /**
     * Creates a new PopupRequest instance using the specified properties.
     * @function create
     * @memberof PopupRequest
     * @static
     * @param {IPopupRequest=} [properties] Properties to set
     * @returns {PopupRequest} PopupRequest instance
     */
    PopupRequest.create = function create(properties) {
        return new PopupRequest(properties);
    };

    /**
     * Encodes the specified PopupRequest message. Does not implicitly {@link PopupRequest.verify|verify} messages.
     * @function encode
     * @memberof PopupRequest
     * @static
     * @param {IPopupRequest} message PopupRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PopupRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.URL != null && Object.hasOwnProperty.call(message, "URL"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.URL);
        if (message.ClientID != null && Object.hasOwnProperty.call(message, "ClientID"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.ClientID);
        if (message.AppName != null && Object.hasOwnProperty.call(message, "AppName"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.AppName);
        if (message.Favicon != null && Object.hasOwnProperty.call(message, "Favicon"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.Favicon);
        if (message.Title != null && Object.hasOwnProperty.call(message, "Title"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.Title);
        if (message.AutoAuthorize != null && Object.hasOwnProperty.call(message, "AutoAuthorize"))
            writer.uint32(/* id 6, wireType 0 =*/48).bool(message.AutoAuthorize);
        if (message.requestID != null && Object.hasOwnProperty.call(message, "requestID"))
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.requestID);
        return writer;
    };

    /**
     * Encodes the specified PopupRequest message, length delimited. Does not implicitly {@link PopupRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PopupRequest
     * @static
     * @param {IPopupRequest} message PopupRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PopupRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PopupRequest message from the specified reader or buffer.
     * @function decode
     * @memberof PopupRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PopupRequest} PopupRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PopupRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PopupRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.URL = reader.string();
                    break;
                }
            case 2: {
                    message.ClientID = reader.string();
                    break;
                }
            case 3: {
                    message.AppName = reader.string();
                    break;
                }
            case 4: {
                    message.Favicon = reader.string();
                    break;
                }
            case 5: {
                    message.Title = reader.string();
                    break;
                }
            case 6: {
                    message.AutoAuthorize = reader.bool();
                    break;
                }
            case 7: {
                    message.requestID = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PopupRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PopupRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PopupRequest} PopupRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PopupRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PopupRequest message.
     * @function verify
     * @memberof PopupRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PopupRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.URL != null && message.hasOwnProperty("URL"))
            if (!$util.isString(message.URL))
                return "URL: string expected";
        if (message.ClientID != null && message.hasOwnProperty("ClientID"))
            if (!$util.isString(message.ClientID))
                return "ClientID: string expected";
        if (message.AppName != null && message.hasOwnProperty("AppName"))
            if (!$util.isString(message.AppName))
                return "AppName: string expected";
        if (message.Favicon != null && message.hasOwnProperty("Favicon"))
            if (!$util.isString(message.Favicon))
                return "Favicon: string expected";
        if (message.Title != null && message.hasOwnProperty("Title"))
            if (!$util.isString(message.Title))
                return "Title: string expected";
        if (message.AutoAuthorize != null && message.hasOwnProperty("AutoAuthorize"))
            if (typeof message.AutoAuthorize !== "boolean")
                return "AutoAuthorize: boolean expected";
        if (message.requestID != null && message.hasOwnProperty("requestID"))
            if (!$util.isString(message.requestID))
                return "requestID: string expected";
        return null;
    };

    /**
     * Creates a PopupRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PopupRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PopupRequest} PopupRequest
     */
    PopupRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.PopupRequest)
            return object;
        let message = new $root.PopupRequest();
        if (object.URL != null)
            message.URL = String(object.URL);
        if (object.ClientID != null)
            message.ClientID = String(object.ClientID);
        if (object.AppName != null)
            message.AppName = String(object.AppName);
        if (object.Favicon != null)
            message.Favicon = String(object.Favicon);
        if (object.Title != null)
            message.Title = String(object.Title);
        if (object.AutoAuthorize != null)
            message.AutoAuthorize = Boolean(object.AutoAuthorize);
        if (object.requestID != null)
            message.requestID = String(object.requestID);
        return message;
    };

    /**
     * Creates a plain object from a PopupRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PopupRequest
     * @static
     * @param {PopupRequest} message PopupRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PopupRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.URL = "";
            object.ClientID = "";
            object.AppName = "";
            object.Favicon = "";
            object.Title = "";
            object.AutoAuthorize = false;
            object.requestID = "";
        }
        if (message.URL != null && message.hasOwnProperty("URL"))
            object.URL = message.URL;
        if (message.ClientID != null && message.hasOwnProperty("ClientID"))
            object.ClientID = message.ClientID;
        if (message.AppName != null && message.hasOwnProperty("AppName"))
            object.AppName = message.AppName;
        if (message.Favicon != null && message.hasOwnProperty("Favicon"))
            object.Favicon = message.Favicon;
        if (message.Title != null && message.hasOwnProperty("Title"))
            object.Title = message.Title;
        if (message.AutoAuthorize != null && message.hasOwnProperty("AutoAuthorize"))
            object.AutoAuthorize = message.AutoAuthorize;
        if (message.requestID != null && message.hasOwnProperty("requestID"))
            object.requestID = message.requestID;
        return object;
    };

    /**
     * Converts this PopupRequest to JSON.
     * @function toJSON
     * @memberof PopupRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PopupRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for PopupRequest
     * @function getTypeUrl
     * @memberof PopupRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    PopupRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/PopupRequest";
    };

    return PopupRequest;
})();

export const PopupResponse = $root.PopupResponse = (() => {

    /**
     * Properties of a PopupResponse.
     * @exports IPopupResponse
     * @interface IPopupResponse
     * @property {string|null} [requestID] PopupResponse requestID
     * @property {boolean|null} [cancelled] PopupResponse cancelled
     * @property {string|null} [resultData] PopupResponse resultData
     */

    /**
     * Constructs a new PopupResponse.
     * @exports PopupResponse
     * @classdesc Represents a PopupResponse.
     * @implements IPopupResponse
     * @constructor
     * @param {IPopupResponse=} [properties] Properties to set
     */
    function PopupResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PopupResponse requestID.
     * @member {string} requestID
     * @memberof PopupResponse
     * @instance
     */
    PopupResponse.prototype.requestID = "";

    /**
     * PopupResponse cancelled.
     * @member {boolean} cancelled
     * @memberof PopupResponse
     * @instance
     */
    PopupResponse.prototype.cancelled = false;

    /**
     * PopupResponse resultData.
     * @member {string} resultData
     * @memberof PopupResponse
     * @instance
     */
    PopupResponse.prototype.resultData = "";

    /**
     * Creates a new PopupResponse instance using the specified properties.
     * @function create
     * @memberof PopupResponse
     * @static
     * @param {IPopupResponse=} [properties] Properties to set
     * @returns {PopupResponse} PopupResponse instance
     */
    PopupResponse.create = function create(properties) {
        return new PopupResponse(properties);
    };

    /**
     * Encodes the specified PopupResponse message. Does not implicitly {@link PopupResponse.verify|verify} messages.
     * @function encode
     * @memberof PopupResponse
     * @static
     * @param {IPopupResponse} message PopupResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PopupResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.requestID != null && Object.hasOwnProperty.call(message, "requestID"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.requestID);
        if (message.cancelled != null && Object.hasOwnProperty.call(message, "cancelled"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.cancelled);
        if (message.resultData != null && Object.hasOwnProperty.call(message, "resultData"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.resultData);
        return writer;
    };

    /**
     * Encodes the specified PopupResponse message, length delimited. Does not implicitly {@link PopupResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PopupResponse
     * @static
     * @param {IPopupResponse} message PopupResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PopupResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PopupResponse message from the specified reader or buffer.
     * @function decode
     * @memberof PopupResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PopupResponse} PopupResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PopupResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PopupResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.requestID = reader.string();
                    break;
                }
            case 2: {
                    message.cancelled = reader.bool();
                    break;
                }
            case 3: {
                    message.resultData = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PopupResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PopupResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PopupResponse} PopupResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PopupResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PopupResponse message.
     * @function verify
     * @memberof PopupResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PopupResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.requestID != null && message.hasOwnProperty("requestID"))
            if (!$util.isString(message.requestID))
                return "requestID: string expected";
        if (message.cancelled != null && message.hasOwnProperty("cancelled"))
            if (typeof message.cancelled !== "boolean")
                return "cancelled: boolean expected";
        if (message.resultData != null && message.hasOwnProperty("resultData"))
            if (!$util.isString(message.resultData))
                return "resultData: string expected";
        return null;
    };

    /**
     * Creates a PopupResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PopupResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PopupResponse} PopupResponse
     */
    PopupResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.PopupResponse)
            return object;
        let message = new $root.PopupResponse();
        if (object.requestID != null)
            message.requestID = String(object.requestID);
        if (object.cancelled != null)
            message.cancelled = Boolean(object.cancelled);
        if (object.resultData != null)
            message.resultData = String(object.resultData);
        return message;
    };

    /**
     * Creates a plain object from a PopupResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PopupResponse
     * @static
     * @param {PopupResponse} message PopupResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PopupResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.requestID = "";
            object.cancelled = false;
            object.resultData = "";
        }
        if (message.requestID != null && message.hasOwnProperty("requestID"))
            object.requestID = message.requestID;
        if (message.cancelled != null && message.hasOwnProperty("cancelled"))
            object.cancelled = message.cancelled;
        if (message.resultData != null && message.hasOwnProperty("resultData"))
            object.resultData = message.resultData;
        return object;
    };

    /**
     * Converts this PopupResponse to JSON.
     * @function toJSON
     * @memberof PopupResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PopupResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for PopupResponse
     * @function getTypeUrl
     * @memberof PopupResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    PopupResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/PopupResponse";
    };

    return PopupResponse;
})();

export const InputRequest = $root.InputRequest = (() => {

    /**
     * Properties of an InputRequest.
     * @exports IInputRequest
     * @interface IInputRequest
     * @property {string|null} [InputType] InputRequest InputType
     * @property {string|null} [InputPlaceholder] InputRequest InputPlaceholder
     * @property {string|null} [ClientID] InputRequest ClientID
     * @property {string|null} [AppName] InputRequest AppName
     * @property {string|null} [Favicon] InputRequest Favicon
     * @property {string|null} [Title] InputRequest Title
     * @property {number|null} [MaxLength] InputRequest MaxLength
     * @property {string|null} [requestID] InputRequest requestID
     */

    /**
     * Constructs a new InputRequest.
     * @exports InputRequest
     * @classdesc Represents an InputRequest.
     * @implements IInputRequest
     * @constructor
     * @param {IInputRequest=} [properties] Properties to set
     */
    function InputRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * InputRequest InputType.
     * @member {string} InputType
     * @memberof InputRequest
     * @instance
     */
    InputRequest.prototype.InputType = "";

    /**
     * InputRequest InputPlaceholder.
     * @member {string} InputPlaceholder
     * @memberof InputRequest
     * @instance
     */
    InputRequest.prototype.InputPlaceholder = "";

    /**
     * InputRequest ClientID.
     * @member {string} ClientID
     * @memberof InputRequest
     * @instance
     */
    InputRequest.prototype.ClientID = "";

    /**
     * InputRequest AppName.
     * @member {string} AppName
     * @memberof InputRequest
     * @instance
     */
    InputRequest.prototype.AppName = "";

    /**
     * InputRequest Favicon.
     * @member {string} Favicon
     * @memberof InputRequest
     * @instance
     */
    InputRequest.prototype.Favicon = "";

    /**
     * InputRequest Title.
     * @member {string} Title
     * @memberof InputRequest
     * @instance
     */
    InputRequest.prototype.Title = "";

    /**
     * InputRequest MaxLength.
     * @member {number} MaxLength
     * @memberof InputRequest
     * @instance
     */
    InputRequest.prototype.MaxLength = 0;

    /**
     * InputRequest requestID.
     * @member {string} requestID
     * @memberof InputRequest
     * @instance
     */
    InputRequest.prototype.requestID = "";

    /**
     * Creates a new InputRequest instance using the specified properties.
     * @function create
     * @memberof InputRequest
     * @static
     * @param {IInputRequest=} [properties] Properties to set
     * @returns {InputRequest} InputRequest instance
     */
    InputRequest.create = function create(properties) {
        return new InputRequest(properties);
    };

    /**
     * Encodes the specified InputRequest message. Does not implicitly {@link InputRequest.verify|verify} messages.
     * @function encode
     * @memberof InputRequest
     * @static
     * @param {IInputRequest} message InputRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    InputRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.InputType != null && Object.hasOwnProperty.call(message, "InputType"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.InputType);
        if (message.InputPlaceholder != null && Object.hasOwnProperty.call(message, "InputPlaceholder"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.InputPlaceholder);
        if (message.ClientID != null && Object.hasOwnProperty.call(message, "ClientID"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.ClientID);
        if (message.AppName != null && Object.hasOwnProperty.call(message, "AppName"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.AppName);
        if (message.Favicon != null && Object.hasOwnProperty.call(message, "Favicon"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.Favicon);
        if (message.Title != null && Object.hasOwnProperty.call(message, "Title"))
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.Title);
        if (message.MaxLength != null && Object.hasOwnProperty.call(message, "MaxLength"))
            writer.uint32(/* id 7, wireType 0 =*/56).int32(message.MaxLength);
        if (message.requestID != null && Object.hasOwnProperty.call(message, "requestID"))
            writer.uint32(/* id 8, wireType 2 =*/66).string(message.requestID);
        return writer;
    };

    /**
     * Encodes the specified InputRequest message, length delimited. Does not implicitly {@link InputRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof InputRequest
     * @static
     * @param {IInputRequest} message InputRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    InputRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an InputRequest message from the specified reader or buffer.
     * @function decode
     * @memberof InputRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {InputRequest} InputRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    InputRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.InputRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.InputType = reader.string();
                    break;
                }
            case 2: {
                    message.InputPlaceholder = reader.string();
                    break;
                }
            case 3: {
                    message.ClientID = reader.string();
                    break;
                }
            case 4: {
                    message.AppName = reader.string();
                    break;
                }
            case 5: {
                    message.Favicon = reader.string();
                    break;
                }
            case 6: {
                    message.Title = reader.string();
                    break;
                }
            case 7: {
                    message.MaxLength = reader.int32();
                    break;
                }
            case 8: {
                    message.requestID = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an InputRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof InputRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {InputRequest} InputRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    InputRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an InputRequest message.
     * @function verify
     * @memberof InputRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    InputRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.InputType != null && message.hasOwnProperty("InputType"))
            if (!$util.isString(message.InputType))
                return "InputType: string expected";
        if (message.InputPlaceholder != null && message.hasOwnProperty("InputPlaceholder"))
            if (!$util.isString(message.InputPlaceholder))
                return "InputPlaceholder: string expected";
        if (message.ClientID != null && message.hasOwnProperty("ClientID"))
            if (!$util.isString(message.ClientID))
                return "ClientID: string expected";
        if (message.AppName != null && message.hasOwnProperty("AppName"))
            if (!$util.isString(message.AppName))
                return "AppName: string expected";
        if (message.Favicon != null && message.hasOwnProperty("Favicon"))
            if (!$util.isString(message.Favicon))
                return "Favicon: string expected";
        if (message.Title != null && message.hasOwnProperty("Title"))
            if (!$util.isString(message.Title))
                return "Title: string expected";
        if (message.MaxLength != null && message.hasOwnProperty("MaxLength"))
            if (!$util.isInteger(message.MaxLength))
                return "MaxLength: integer expected";
        if (message.requestID != null && message.hasOwnProperty("requestID"))
            if (!$util.isString(message.requestID))
                return "requestID: string expected";
        return null;
    };

    /**
     * Creates an InputRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof InputRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {InputRequest} InputRequest
     */
    InputRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.InputRequest)
            return object;
        let message = new $root.InputRequest();
        if (object.InputType != null)
            message.InputType = String(object.InputType);
        if (object.InputPlaceholder != null)
            message.InputPlaceholder = String(object.InputPlaceholder);
        if (object.ClientID != null)
            message.ClientID = String(object.ClientID);
        if (object.AppName != null)
            message.AppName = String(object.AppName);
        if (object.Favicon != null)
            message.Favicon = String(object.Favicon);
        if (object.Title != null)
            message.Title = String(object.Title);
        if (object.MaxLength != null)
            message.MaxLength = object.MaxLength | 0;
        if (object.requestID != null)
            message.requestID = String(object.requestID);
        return message;
    };

    /**
     * Creates a plain object from an InputRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof InputRequest
     * @static
     * @param {InputRequest} message InputRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    InputRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.InputType = "";
            object.InputPlaceholder = "";
            object.ClientID = "";
            object.AppName = "";
            object.Favicon = "";
            object.Title = "";
            object.MaxLength = 0;
            object.requestID = "";
        }
        if (message.InputType != null && message.hasOwnProperty("InputType"))
            object.InputType = message.InputType;
        if (message.InputPlaceholder != null && message.hasOwnProperty("InputPlaceholder"))
            object.InputPlaceholder = message.InputPlaceholder;
        if (message.ClientID != null && message.hasOwnProperty("ClientID"))
            object.ClientID = message.ClientID;
        if (message.AppName != null && message.hasOwnProperty("AppName"))
            object.AppName = message.AppName;
        if (message.Favicon != null && message.hasOwnProperty("Favicon"))
            object.Favicon = message.Favicon;
        if (message.Title != null && message.hasOwnProperty("Title"))
            object.Title = message.Title;
        if (message.MaxLength != null && message.hasOwnProperty("MaxLength"))
            object.MaxLength = message.MaxLength;
        if (message.requestID != null && message.hasOwnProperty("requestID"))
            object.requestID = message.requestID;
        return object;
    };

    /**
     * Converts this InputRequest to JSON.
     * @function toJSON
     * @memberof InputRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    InputRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for InputRequest
     * @function getTypeUrl
     * @memberof InputRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    InputRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/InputRequest";
    };

    return InputRequest;
})();

export const InputResponse = $root.InputResponse = (() => {

    /**
     * Properties of an InputResponse.
     * @exports IInputResponse
     * @interface IInputResponse
     * @property {string|null} [requestID] InputResponse requestID
     * @property {boolean|null} [cancelled] InputResponse cancelled
     * @property {string|null} [resultData] InputResponse resultData
     */

    /**
     * Constructs a new InputResponse.
     * @exports InputResponse
     * @classdesc Represents an InputResponse.
     * @implements IInputResponse
     * @constructor
     * @param {IInputResponse=} [properties] Properties to set
     */
    function InputResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * InputResponse requestID.
     * @member {string} requestID
     * @memberof InputResponse
     * @instance
     */
    InputResponse.prototype.requestID = "";

    /**
     * InputResponse cancelled.
     * @member {boolean} cancelled
     * @memberof InputResponse
     * @instance
     */
    InputResponse.prototype.cancelled = false;

    /**
     * InputResponse resultData.
     * @member {string} resultData
     * @memberof InputResponse
     * @instance
     */
    InputResponse.prototype.resultData = "";

    /**
     * Creates a new InputResponse instance using the specified properties.
     * @function create
     * @memberof InputResponse
     * @static
     * @param {IInputResponse=} [properties] Properties to set
     * @returns {InputResponse} InputResponse instance
     */
    InputResponse.create = function create(properties) {
        return new InputResponse(properties);
    };

    /**
     * Encodes the specified InputResponse message. Does not implicitly {@link InputResponse.verify|verify} messages.
     * @function encode
     * @memberof InputResponse
     * @static
     * @param {IInputResponse} message InputResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    InputResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.requestID != null && Object.hasOwnProperty.call(message, "requestID"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.requestID);
        if (message.cancelled != null && Object.hasOwnProperty.call(message, "cancelled"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.cancelled);
        if (message.resultData != null && Object.hasOwnProperty.call(message, "resultData"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.resultData);
        return writer;
    };

    /**
     * Encodes the specified InputResponse message, length delimited. Does not implicitly {@link InputResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof InputResponse
     * @static
     * @param {IInputResponse} message InputResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    InputResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an InputResponse message from the specified reader or buffer.
     * @function decode
     * @memberof InputResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {InputResponse} InputResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    InputResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.InputResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.requestID = reader.string();
                    break;
                }
            case 2: {
                    message.cancelled = reader.bool();
                    break;
                }
            case 3: {
                    message.resultData = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an InputResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof InputResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {InputResponse} InputResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    InputResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an InputResponse message.
     * @function verify
     * @memberof InputResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    InputResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.requestID != null && message.hasOwnProperty("requestID"))
            if (!$util.isString(message.requestID))
                return "requestID: string expected";
        if (message.cancelled != null && message.hasOwnProperty("cancelled"))
            if (typeof message.cancelled !== "boolean")
                return "cancelled: boolean expected";
        if (message.resultData != null && message.hasOwnProperty("resultData"))
            if (!$util.isString(message.resultData))
                return "resultData: string expected";
        return null;
    };

    /**
     * Creates an InputResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof InputResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {InputResponse} InputResponse
     */
    InputResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.InputResponse)
            return object;
        let message = new $root.InputResponse();
        if (object.requestID != null)
            message.requestID = String(object.requestID);
        if (object.cancelled != null)
            message.cancelled = Boolean(object.cancelled);
        if (object.resultData != null)
            message.resultData = String(object.resultData);
        return message;
    };

    /**
     * Creates a plain object from an InputResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof InputResponse
     * @static
     * @param {InputResponse} message InputResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    InputResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.requestID = "";
            object.cancelled = false;
            object.resultData = "";
        }
        if (message.requestID != null && message.hasOwnProperty("requestID"))
            object.requestID = message.requestID;
        if (message.cancelled != null && message.hasOwnProperty("cancelled"))
            object.cancelled = message.cancelled;
        if (message.resultData != null && message.hasOwnProperty("resultData"))
            object.resultData = message.resultData;
        return object;
    };

    /**
     * Converts this InputResponse to JSON.
     * @function toJSON
     * @memberof InputResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    InputResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for InputResponse
     * @function getTypeUrl
     * @memberof InputResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    InputResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/InputResponse";
    };

    return InputResponse;
})();

export const ShutdownRequest = $root.ShutdownRequest = (() => {

    /**
     * Properties of a ShutdownRequest.
     * @exports IShutdownRequest
     * @interface IShutdownRequest
     */

    /**
     * Constructs a new ShutdownRequest.
     * @exports ShutdownRequest
     * @classdesc Represents a ShutdownRequest.
     * @implements IShutdownRequest
     * @constructor
     * @param {IShutdownRequest=} [properties] Properties to set
     */
    function ShutdownRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new ShutdownRequest instance using the specified properties.
     * @function create
     * @memberof ShutdownRequest
     * @static
     * @param {IShutdownRequest=} [properties] Properties to set
     * @returns {ShutdownRequest} ShutdownRequest instance
     */
    ShutdownRequest.create = function create(properties) {
        return new ShutdownRequest(properties);
    };

    /**
     * Encodes the specified ShutdownRequest message. Does not implicitly {@link ShutdownRequest.verify|verify} messages.
     * @function encode
     * @memberof ShutdownRequest
     * @static
     * @param {IShutdownRequest} message ShutdownRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ShutdownRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified ShutdownRequest message, length delimited. Does not implicitly {@link ShutdownRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ShutdownRequest
     * @static
     * @param {IShutdownRequest} message ShutdownRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ShutdownRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ShutdownRequest message from the specified reader or buffer.
     * @function decode
     * @memberof ShutdownRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ShutdownRequest} ShutdownRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ShutdownRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ShutdownRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ShutdownRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ShutdownRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ShutdownRequest} ShutdownRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ShutdownRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ShutdownRequest message.
     * @function verify
     * @memberof ShutdownRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ShutdownRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a ShutdownRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ShutdownRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ShutdownRequest} ShutdownRequest
     */
    ShutdownRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ShutdownRequest)
            return object;
        return new $root.ShutdownRequest();
    };

    /**
     * Creates a plain object from a ShutdownRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ShutdownRequest
     * @static
     * @param {ShutdownRequest} message ShutdownRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ShutdownRequest.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this ShutdownRequest to JSON.
     * @function toJSON
     * @memberof ShutdownRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ShutdownRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ShutdownRequest
     * @function getTypeUrl
     * @memberof ShutdownRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ShutdownRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/ShutdownRequest";
    };

    return ShutdownRequest;
})();

export const PopupAppControlMessage = $root.PopupAppControlMessage = (() => {

    /**
     * Properties of a PopupAppControlMessage.
     * @exports IPopupAppControlMessage
     * @interface IPopupAppControlMessage
     * @property {PopupAppControlMessage.MessageType|null} [type] PopupAppControlMessage type
     * @property {IPopupRequest|null} [popupRequest] PopupAppControlMessage popupRequest
     * @property {IInputRequest|null} [inputRequest] PopupAppControlMessage inputRequest
     * @property {IShutdownRequest|null} [shutdownRequest] PopupAppControlMessage shutdownRequest
     */

    /**
     * Constructs a new PopupAppControlMessage.
     * @exports PopupAppControlMessage
     * @classdesc Represents a PopupAppControlMessage.
     * @implements IPopupAppControlMessage
     * @constructor
     * @param {IPopupAppControlMessage=} [properties] Properties to set
     */
    function PopupAppControlMessage(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PopupAppControlMessage type.
     * @member {PopupAppControlMessage.MessageType} type
     * @memberof PopupAppControlMessage
     * @instance
     */
    PopupAppControlMessage.prototype.type = 0;

    /**
     * PopupAppControlMessage popupRequest.
     * @member {IPopupRequest|null|undefined} popupRequest
     * @memberof PopupAppControlMessage
     * @instance
     */
    PopupAppControlMessage.prototype.popupRequest = null;

    /**
     * PopupAppControlMessage inputRequest.
     * @member {IInputRequest|null|undefined} inputRequest
     * @memberof PopupAppControlMessage
     * @instance
     */
    PopupAppControlMessage.prototype.inputRequest = null;

    /**
     * PopupAppControlMessage shutdownRequest.
     * @member {IShutdownRequest|null|undefined} shutdownRequest
     * @memberof PopupAppControlMessage
     * @instance
     */
    PopupAppControlMessage.prototype.shutdownRequest = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * PopupAppControlMessage message.
     * @member {"popupRequest"|"inputRequest"|"shutdownRequest"|undefined} message
     * @memberof PopupAppControlMessage
     * @instance
     */
    Object.defineProperty(PopupAppControlMessage.prototype, "message", {
        get: $util.oneOfGetter($oneOfFields = ["popupRequest", "inputRequest", "shutdownRequest"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new PopupAppControlMessage instance using the specified properties.
     * @function create
     * @memberof PopupAppControlMessage
     * @static
     * @param {IPopupAppControlMessage=} [properties] Properties to set
     * @returns {PopupAppControlMessage} PopupAppControlMessage instance
     */
    PopupAppControlMessage.create = function create(properties) {
        return new PopupAppControlMessage(properties);
    };

    /**
     * Encodes the specified PopupAppControlMessage message. Does not implicitly {@link PopupAppControlMessage.verify|verify} messages.
     * @function encode
     * @memberof PopupAppControlMessage
     * @static
     * @param {IPopupAppControlMessage} message PopupAppControlMessage message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PopupAppControlMessage.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        if (message.popupRequest != null && Object.hasOwnProperty.call(message, "popupRequest"))
            $root.PopupRequest.encode(message.popupRequest, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.inputRequest != null && Object.hasOwnProperty.call(message, "inputRequest"))
            $root.InputRequest.encode(message.inputRequest, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.shutdownRequest != null && Object.hasOwnProperty.call(message, "shutdownRequest"))
            $root.ShutdownRequest.encode(message.shutdownRequest, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified PopupAppControlMessage message, length delimited. Does not implicitly {@link PopupAppControlMessage.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PopupAppControlMessage
     * @static
     * @param {IPopupAppControlMessage} message PopupAppControlMessage message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PopupAppControlMessage.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PopupAppControlMessage message from the specified reader or buffer.
     * @function decode
     * @memberof PopupAppControlMessage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PopupAppControlMessage} PopupAppControlMessage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PopupAppControlMessage.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PopupAppControlMessage();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.type = reader.int32();
                    break;
                }
            case 2: {
                    message.popupRequest = $root.PopupRequest.decode(reader, reader.uint32());
                    break;
                }
            case 3: {
                    message.inputRequest = $root.InputRequest.decode(reader, reader.uint32());
                    break;
                }
            case 4: {
                    message.shutdownRequest = $root.ShutdownRequest.decode(reader, reader.uint32());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PopupAppControlMessage message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PopupAppControlMessage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PopupAppControlMessage} PopupAppControlMessage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PopupAppControlMessage.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PopupAppControlMessage message.
     * @function verify
     * @memberof PopupAppControlMessage
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PopupAppControlMessage.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        if (message.popupRequest != null && message.hasOwnProperty("popupRequest")) {
            properties.message = 1;
            {
                let error = $root.PopupRequest.verify(message.popupRequest);
                if (error)
                    return "popupRequest." + error;
            }
        }
        if (message.inputRequest != null && message.hasOwnProperty("inputRequest")) {
            if (properties.message === 1)
                return "message: multiple values";
            properties.message = 1;
            {
                let error = $root.InputRequest.verify(message.inputRequest);
                if (error)
                    return "inputRequest." + error;
            }
        }
        if (message.shutdownRequest != null && message.hasOwnProperty("shutdownRequest")) {
            if (properties.message === 1)
                return "message: multiple values";
            properties.message = 1;
            {
                let error = $root.ShutdownRequest.verify(message.shutdownRequest);
                if (error)
                    return "shutdownRequest." + error;
            }
        }
        return null;
    };

    /**
     * Creates a PopupAppControlMessage message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PopupAppControlMessage
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PopupAppControlMessage} PopupAppControlMessage
     */
    PopupAppControlMessage.fromObject = function fromObject(object) {
        if (object instanceof $root.PopupAppControlMessage)
            return object;
        let message = new $root.PopupAppControlMessage();
        switch (object.type) {
        default:
            if (typeof object.type === "number") {
                message.type = object.type;
                break;
            }
            break;
        case "POPUP":
        case 0:
            message.type = 0;
            break;
        case "INPUT":
        case 1:
            message.type = 1;
            break;
        case "SHUTDOWN":
        case 2:
            message.type = 2;
            break;
        }
        if (object.popupRequest != null) {
            if (typeof object.popupRequest !== "object")
                throw TypeError(".PopupAppControlMessage.popupRequest: object expected");
            message.popupRequest = $root.PopupRequest.fromObject(object.popupRequest);
        }
        if (object.inputRequest != null) {
            if (typeof object.inputRequest !== "object")
                throw TypeError(".PopupAppControlMessage.inputRequest: object expected");
            message.inputRequest = $root.InputRequest.fromObject(object.inputRequest);
        }
        if (object.shutdownRequest != null) {
            if (typeof object.shutdownRequest !== "object")
                throw TypeError(".PopupAppControlMessage.shutdownRequest: object expected");
            message.shutdownRequest = $root.ShutdownRequest.fromObject(object.shutdownRequest);
        }
        return message;
    };

    /**
     * Creates a plain object from a PopupAppControlMessage message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PopupAppControlMessage
     * @static
     * @param {PopupAppControlMessage} message PopupAppControlMessage
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PopupAppControlMessage.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.type = options.enums === String ? "POPUP" : 0;
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.PopupAppControlMessage.MessageType[message.type] === undefined ? message.type : $root.PopupAppControlMessage.MessageType[message.type] : message.type;
        if (message.popupRequest != null && message.hasOwnProperty("popupRequest")) {
            object.popupRequest = $root.PopupRequest.toObject(message.popupRequest, options);
            if (options.oneofs)
                object.message = "popupRequest";
        }
        if (message.inputRequest != null && message.hasOwnProperty("inputRequest")) {
            object.inputRequest = $root.InputRequest.toObject(message.inputRequest, options);
            if (options.oneofs)
                object.message = "inputRequest";
        }
        if (message.shutdownRequest != null && message.hasOwnProperty("shutdownRequest")) {
            object.shutdownRequest = $root.ShutdownRequest.toObject(message.shutdownRequest, options);
            if (options.oneofs)
                object.message = "shutdownRequest";
        }
        return object;
    };

    /**
     * Converts this PopupAppControlMessage to JSON.
     * @function toJSON
     * @memberof PopupAppControlMessage
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PopupAppControlMessage.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for PopupAppControlMessage
     * @function getTypeUrl
     * @memberof PopupAppControlMessage
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    PopupAppControlMessage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/PopupAppControlMessage";
    };

    /**
     * MessageType enum.
     * @name PopupAppControlMessage.MessageType
     * @enum {number}
     * @property {number} POPUP=0 POPUP value
     * @property {number} INPUT=1 INPUT value
     * @property {number} SHUTDOWN=2 SHUTDOWN value
     */
    PopupAppControlMessage.MessageType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "POPUP"] = 0;
        values[valuesById[1] = "INPUT"] = 1;
        values[valuesById[2] = "SHUTDOWN"] = 2;
        return values;
    })();

    return PopupAppControlMessage;
})();

export const PopupAppResponse = $root.PopupAppResponse = (() => {

    /**
     * Properties of a PopupAppResponse.
     * @exports IPopupAppResponse
     * @interface IPopupAppResponse
     * @property {IPopupResponse|null} [popupResponse] PopupAppResponse popupResponse
     * @property {IInputResponse|null} [inputResponse] PopupAppResponse inputResponse
     */

    /**
     * Constructs a new PopupAppResponse.
     * @exports PopupAppResponse
     * @classdesc Represents a PopupAppResponse.
     * @implements IPopupAppResponse
     * @constructor
     * @param {IPopupAppResponse=} [properties] Properties to set
     */
    function PopupAppResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PopupAppResponse popupResponse.
     * @member {IPopupResponse|null|undefined} popupResponse
     * @memberof PopupAppResponse
     * @instance
     */
    PopupAppResponse.prototype.popupResponse = null;

    /**
     * PopupAppResponse inputResponse.
     * @member {IInputResponse|null|undefined} inputResponse
     * @memberof PopupAppResponse
     * @instance
     */
    PopupAppResponse.prototype.inputResponse = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * PopupAppResponse message.
     * @member {"popupResponse"|"inputResponse"|undefined} message
     * @memberof PopupAppResponse
     * @instance
     */
    Object.defineProperty(PopupAppResponse.prototype, "message", {
        get: $util.oneOfGetter($oneOfFields = ["popupResponse", "inputResponse"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new PopupAppResponse instance using the specified properties.
     * @function create
     * @memberof PopupAppResponse
     * @static
     * @param {IPopupAppResponse=} [properties] Properties to set
     * @returns {PopupAppResponse} PopupAppResponse instance
     */
    PopupAppResponse.create = function create(properties) {
        return new PopupAppResponse(properties);
    };

    /**
     * Encodes the specified PopupAppResponse message. Does not implicitly {@link PopupAppResponse.verify|verify} messages.
     * @function encode
     * @memberof PopupAppResponse
     * @static
     * @param {IPopupAppResponse} message PopupAppResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PopupAppResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.popupResponse != null && Object.hasOwnProperty.call(message, "popupResponse"))
            $root.PopupResponse.encode(message.popupResponse, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.inputResponse != null && Object.hasOwnProperty.call(message, "inputResponse"))
            $root.InputResponse.encode(message.inputResponse, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified PopupAppResponse message, length delimited. Does not implicitly {@link PopupAppResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PopupAppResponse
     * @static
     * @param {IPopupAppResponse} message PopupAppResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PopupAppResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PopupAppResponse message from the specified reader or buffer.
     * @function decode
     * @memberof PopupAppResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PopupAppResponse} PopupAppResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PopupAppResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PopupAppResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.popupResponse = $root.PopupResponse.decode(reader, reader.uint32());
                    break;
                }
            case 2: {
                    message.inputResponse = $root.InputResponse.decode(reader, reader.uint32());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PopupAppResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PopupAppResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PopupAppResponse} PopupAppResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PopupAppResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PopupAppResponse message.
     * @function verify
     * @memberof PopupAppResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PopupAppResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.popupResponse != null && message.hasOwnProperty("popupResponse")) {
            properties.message = 1;
            {
                let error = $root.PopupResponse.verify(message.popupResponse);
                if (error)
                    return "popupResponse." + error;
            }
        }
        if (message.inputResponse != null && message.hasOwnProperty("inputResponse")) {
            if (properties.message === 1)
                return "message: multiple values";
            properties.message = 1;
            {
                let error = $root.InputResponse.verify(message.inputResponse);
                if (error)
                    return "inputResponse." + error;
            }
        }
        return null;
    };

    /**
     * Creates a PopupAppResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PopupAppResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PopupAppResponse} PopupAppResponse
     */
    PopupAppResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.PopupAppResponse)
            return object;
        let message = new $root.PopupAppResponse();
        if (object.popupResponse != null) {
            if (typeof object.popupResponse !== "object")
                throw TypeError(".PopupAppResponse.popupResponse: object expected");
            message.popupResponse = $root.PopupResponse.fromObject(object.popupResponse);
        }
        if (object.inputResponse != null) {
            if (typeof object.inputResponse !== "object")
                throw TypeError(".PopupAppResponse.inputResponse: object expected");
            message.inputResponse = $root.InputResponse.fromObject(object.inputResponse);
        }
        return message;
    };

    /**
     * Creates a plain object from a PopupAppResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PopupAppResponse
     * @static
     * @param {PopupAppResponse} message PopupAppResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PopupAppResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (message.popupResponse != null && message.hasOwnProperty("popupResponse")) {
            object.popupResponse = $root.PopupResponse.toObject(message.popupResponse, options);
            if (options.oneofs)
                object.message = "popupResponse";
        }
        if (message.inputResponse != null && message.hasOwnProperty("inputResponse")) {
            object.inputResponse = $root.InputResponse.toObject(message.inputResponse, options);
            if (options.oneofs)
                object.message = "inputResponse";
        }
        return object;
    };

    /**
     * Converts this PopupAppResponse to JSON.
     * @function toJSON
     * @memberof PopupAppResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PopupAppResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for PopupAppResponse
     * @function getTypeUrl
     * @memberof PopupAppResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    PopupAppResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/PopupAppResponse";
    };

    /**
     * MessageType enum.
     * @name PopupAppResponse.MessageType
     * @enum {number}
     * @property {number} POPUP=0 POPUP value
     * @property {number} INPUT=1 INPUT value
     */
    PopupAppResponse.MessageType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "POPUP"] = 0;
        values[valuesById[1] = "INPUT"] = 1;
        return values;
    })();

    return PopupAppResponse;
})();

export const PanelSystemInitialResponse = $root.PanelSystemInitialResponse = (() => {

    /**
     * Properties of a PanelSystemInitialResponse.
     * @exports IPanelSystemInitialResponse
     * @interface IPanelSystemInitialResponse
     * @property {Array.<IBasePanel>|null} [templatePanels] PanelSystemInitialResponse templatePanels
     * @property {Array.<IRuntimePanel>|null} [instancedButBlankPanels] PanelSystemInitialResponse instancedButBlankPanels
     * @property {Array.<IRuntimePanel>|null} [instancedPanelsFromStorage] PanelSystemInitialResponse instancedPanelsFromStorage
     * @property {Array.<IRuntimePanel>|null} [deletedInstancedPanels] PanelSystemInitialResponse deletedInstancedPanels
     */

    /**
     * Constructs a new PanelSystemInitialResponse.
     * @exports PanelSystemInitialResponse
     * @classdesc Represents a PanelSystemInitialResponse.
     * @implements IPanelSystemInitialResponse
     * @constructor
     * @param {IPanelSystemInitialResponse=} [properties] Properties to set
     */
    function PanelSystemInitialResponse(properties) {
        this.templatePanels = [];
        this.instancedButBlankPanels = [];
        this.instancedPanelsFromStorage = [];
        this.deletedInstancedPanels = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PanelSystemInitialResponse templatePanels.
     * @member {Array.<IBasePanel>} templatePanels
     * @memberof PanelSystemInitialResponse
     * @instance
     */
    PanelSystemInitialResponse.prototype.templatePanels = $util.emptyArray;

    /**
     * PanelSystemInitialResponse instancedButBlankPanels.
     * @member {Array.<IRuntimePanel>} instancedButBlankPanels
     * @memberof PanelSystemInitialResponse
     * @instance
     */
    PanelSystemInitialResponse.prototype.instancedButBlankPanels = $util.emptyArray;

    /**
     * PanelSystemInitialResponse instancedPanelsFromStorage.
     * @member {Array.<IRuntimePanel>} instancedPanelsFromStorage
     * @memberof PanelSystemInitialResponse
     * @instance
     */
    PanelSystemInitialResponse.prototype.instancedPanelsFromStorage = $util.emptyArray;

    /**
     * PanelSystemInitialResponse deletedInstancedPanels.
     * @member {Array.<IRuntimePanel>} deletedInstancedPanels
     * @memberof PanelSystemInitialResponse
     * @instance
     */
    PanelSystemInitialResponse.prototype.deletedInstancedPanels = $util.emptyArray;

    /**
     * Creates a new PanelSystemInitialResponse instance using the specified properties.
     * @function create
     * @memberof PanelSystemInitialResponse
     * @static
     * @param {IPanelSystemInitialResponse=} [properties] Properties to set
     * @returns {PanelSystemInitialResponse} PanelSystemInitialResponse instance
     */
    PanelSystemInitialResponse.create = function create(properties) {
        return new PanelSystemInitialResponse(properties);
    };

    /**
     * Encodes the specified PanelSystemInitialResponse message. Does not implicitly {@link PanelSystemInitialResponse.verify|verify} messages.
     * @function encode
     * @memberof PanelSystemInitialResponse
     * @static
     * @param {IPanelSystemInitialResponse} message PanelSystemInitialResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PanelSystemInitialResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.templatePanels != null && message.templatePanels.length)
            for (let i = 0; i < message.templatePanels.length; ++i)
                $root.BasePanel.encode(message.templatePanels[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.instancedButBlankPanels != null && message.instancedButBlankPanels.length)
            for (let i = 0; i < message.instancedButBlankPanels.length; ++i)
                $root.RuntimePanel.encode(message.instancedButBlankPanels[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.instancedPanelsFromStorage != null && message.instancedPanelsFromStorage.length)
            for (let i = 0; i < message.instancedPanelsFromStorage.length; ++i)
                $root.RuntimePanel.encode(message.instancedPanelsFromStorage[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.deletedInstancedPanels != null && message.deletedInstancedPanels.length)
            for (let i = 0; i < message.deletedInstancedPanels.length; ++i)
                $root.RuntimePanel.encode(message.deletedInstancedPanels[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified PanelSystemInitialResponse message, length delimited. Does not implicitly {@link PanelSystemInitialResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PanelSystemInitialResponse
     * @static
     * @param {IPanelSystemInitialResponse} message PanelSystemInitialResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PanelSystemInitialResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PanelSystemInitialResponse message from the specified reader or buffer.
     * @function decode
     * @memberof PanelSystemInitialResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PanelSystemInitialResponse} PanelSystemInitialResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PanelSystemInitialResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PanelSystemInitialResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    if (!(message.templatePanels && message.templatePanels.length))
                        message.templatePanels = [];
                    message.templatePanels.push($root.BasePanel.decode(reader, reader.uint32()));
                    break;
                }
            case 2: {
                    if (!(message.instancedButBlankPanels && message.instancedButBlankPanels.length))
                        message.instancedButBlankPanels = [];
                    message.instancedButBlankPanels.push($root.RuntimePanel.decode(reader, reader.uint32()));
                    break;
                }
            case 3: {
                    if (!(message.instancedPanelsFromStorage && message.instancedPanelsFromStorage.length))
                        message.instancedPanelsFromStorage = [];
                    message.instancedPanelsFromStorage.push($root.RuntimePanel.decode(reader, reader.uint32()));
                    break;
                }
            case 4: {
                    if (!(message.deletedInstancedPanels && message.deletedInstancedPanels.length))
                        message.deletedInstancedPanels = [];
                    message.deletedInstancedPanels.push($root.RuntimePanel.decode(reader, reader.uint32()));
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PanelSystemInitialResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PanelSystemInitialResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PanelSystemInitialResponse} PanelSystemInitialResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PanelSystemInitialResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PanelSystemInitialResponse message.
     * @function verify
     * @memberof PanelSystemInitialResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PanelSystemInitialResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.templatePanels != null && message.hasOwnProperty("templatePanels")) {
            if (!Array.isArray(message.templatePanels))
                return "templatePanels: array expected";
            for (let i = 0; i < message.templatePanels.length; ++i) {
                let error = $root.BasePanel.verify(message.templatePanels[i]);
                if (error)
                    return "templatePanels." + error;
            }
        }
        if (message.instancedButBlankPanels != null && message.hasOwnProperty("instancedButBlankPanels")) {
            if (!Array.isArray(message.instancedButBlankPanels))
                return "instancedButBlankPanels: array expected";
            for (let i = 0; i < message.instancedButBlankPanels.length; ++i) {
                let error = $root.RuntimePanel.verify(message.instancedButBlankPanels[i]);
                if (error)
                    return "instancedButBlankPanels." + error;
            }
        }
        if (message.instancedPanelsFromStorage != null && message.hasOwnProperty("instancedPanelsFromStorage")) {
            if (!Array.isArray(message.instancedPanelsFromStorage))
                return "instancedPanelsFromStorage: array expected";
            for (let i = 0; i < message.instancedPanelsFromStorage.length; ++i) {
                let error = $root.RuntimePanel.verify(message.instancedPanelsFromStorage[i]);
                if (error)
                    return "instancedPanelsFromStorage." + error;
            }
        }
        if (message.deletedInstancedPanels != null && message.hasOwnProperty("deletedInstancedPanels")) {
            if (!Array.isArray(message.deletedInstancedPanels))
                return "deletedInstancedPanels: array expected";
            for (let i = 0; i < message.deletedInstancedPanels.length; ++i) {
                let error = $root.RuntimePanel.verify(message.deletedInstancedPanels[i]);
                if (error)
                    return "deletedInstancedPanels." + error;
            }
        }
        return null;
    };

    /**
     * Creates a PanelSystemInitialResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PanelSystemInitialResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PanelSystemInitialResponse} PanelSystemInitialResponse
     */
    PanelSystemInitialResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.PanelSystemInitialResponse)
            return object;
        let message = new $root.PanelSystemInitialResponse();
        if (object.templatePanels) {
            if (!Array.isArray(object.templatePanels))
                throw TypeError(".PanelSystemInitialResponse.templatePanels: array expected");
            message.templatePanels = [];
            for (let i = 0; i < object.templatePanels.length; ++i) {
                if (typeof object.templatePanels[i] !== "object")
                    throw TypeError(".PanelSystemInitialResponse.templatePanels: object expected");
                message.templatePanels[i] = $root.BasePanel.fromObject(object.templatePanels[i]);
            }
        }
        if (object.instancedButBlankPanels) {
            if (!Array.isArray(object.instancedButBlankPanels))
                throw TypeError(".PanelSystemInitialResponse.instancedButBlankPanels: array expected");
            message.instancedButBlankPanels = [];
            for (let i = 0; i < object.instancedButBlankPanels.length; ++i) {
                if (typeof object.instancedButBlankPanels[i] !== "object")
                    throw TypeError(".PanelSystemInitialResponse.instancedButBlankPanels: object expected");
                message.instancedButBlankPanels[i] = $root.RuntimePanel.fromObject(object.instancedButBlankPanels[i]);
            }
        }
        if (object.instancedPanelsFromStorage) {
            if (!Array.isArray(object.instancedPanelsFromStorage))
                throw TypeError(".PanelSystemInitialResponse.instancedPanelsFromStorage: array expected");
            message.instancedPanelsFromStorage = [];
            for (let i = 0; i < object.instancedPanelsFromStorage.length; ++i) {
                if (typeof object.instancedPanelsFromStorage[i] !== "object")
                    throw TypeError(".PanelSystemInitialResponse.instancedPanelsFromStorage: object expected");
                message.instancedPanelsFromStorage[i] = $root.RuntimePanel.fromObject(object.instancedPanelsFromStorage[i]);
            }
        }
        if (object.deletedInstancedPanels) {
            if (!Array.isArray(object.deletedInstancedPanels))
                throw TypeError(".PanelSystemInitialResponse.deletedInstancedPanels: array expected");
            message.deletedInstancedPanels = [];
            for (let i = 0; i < object.deletedInstancedPanels.length; ++i) {
                if (typeof object.deletedInstancedPanels[i] !== "object")
                    throw TypeError(".PanelSystemInitialResponse.deletedInstancedPanels: object expected");
                message.deletedInstancedPanels[i] = $root.RuntimePanel.fromObject(object.deletedInstancedPanels[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a PanelSystemInitialResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PanelSystemInitialResponse
     * @static
     * @param {PanelSystemInitialResponse} message PanelSystemInitialResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PanelSystemInitialResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults) {
            object.templatePanels = [];
            object.instancedButBlankPanels = [];
            object.instancedPanelsFromStorage = [];
            object.deletedInstancedPanels = [];
        }
        if (message.templatePanels && message.templatePanels.length) {
            object.templatePanels = [];
            for (let j = 0; j < message.templatePanels.length; ++j)
                object.templatePanels[j] = $root.BasePanel.toObject(message.templatePanels[j], options);
        }
        if (message.instancedButBlankPanels && message.instancedButBlankPanels.length) {
            object.instancedButBlankPanels = [];
            for (let j = 0; j < message.instancedButBlankPanels.length; ++j)
                object.instancedButBlankPanels[j] = $root.RuntimePanel.toObject(message.instancedButBlankPanels[j], options);
        }
        if (message.instancedPanelsFromStorage && message.instancedPanelsFromStorage.length) {
            object.instancedPanelsFromStorage = [];
            for (let j = 0; j < message.instancedPanelsFromStorage.length; ++j)
                object.instancedPanelsFromStorage[j] = $root.RuntimePanel.toObject(message.instancedPanelsFromStorage[j], options);
        }
        if (message.deletedInstancedPanels && message.deletedInstancedPanels.length) {
            object.deletedInstancedPanels = [];
            for (let j = 0; j < message.deletedInstancedPanels.length; ++j)
                object.deletedInstancedPanels[j] = $root.RuntimePanel.toObject(message.deletedInstancedPanels[j], options);
        }
        return object;
    };

    /**
     * Converts this PanelSystemInitialResponse to JSON.
     * @function toJSON
     * @memberof PanelSystemInitialResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PanelSystemInitialResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for PanelSystemInitialResponse
     * @function getTypeUrl
     * @memberof PanelSystemInitialResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    PanelSystemInitialResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/PanelSystemInitialResponse";
    };

    return PanelSystemInitialResponse;
})();

export const BasePanel = $root.BasePanel = (() => {

    /**
     * Properties of a BasePanel.
     * @exports IBasePanel
     * @interface IBasePanel
     * @property {string|null} [PanelType] BasePanel PanelType
     * @property {string|null} [PanelTitle] BasePanel PanelTitle
     * @property {string|null} [PanelContent] BasePanel PanelContent
     * @property {number|null} [PanelRecommendedWidth] BasePanel PanelRecommendedWidth
     * @property {number|null} [PanelRecommendedHeight] BasePanel PanelRecommendedHeight
     * @property {number|null} [PanelMinWidth] BasePanel PanelMinWidth
     * @property {number|null} [PanelMinHeight] BasePanel PanelMinHeight
     * @property {number|null} [PanelMaxWidth] BasePanel PanelMaxWidth
     * @property {number|null} [PanelMaxHeight] BasePanel PanelMaxHeight
     * @property {number|null} [PanelRecommendedX] BasePanel PanelRecommendedX
     * @property {number|null} [PanelRecommendedY] BasePanel PanelRecommendedY
     * @property {string|null} [DefaultData] BasePanel DefaultData
     * @property {string|null} [PanelIcon] BasePanel PanelIcon
     * @property {string|null} [AppClientID] BasePanel AppClientID
     * @property {string|null} [FixedPanelID] BasePanel FixedPanelID
     */

    /**
     * Constructs a new BasePanel.
     * @exports BasePanel
     * @classdesc Represents a BasePanel.
     * @implements IBasePanel
     * @constructor
     * @param {IBasePanel=} [properties] Properties to set
     */
    function BasePanel(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BasePanel PanelType.
     * @member {string} PanelType
     * @memberof BasePanel
     * @instance
     */
    BasePanel.prototype.PanelType = "";

    /**
     * BasePanel PanelTitle.
     * @member {string} PanelTitle
     * @memberof BasePanel
     * @instance
     */
    BasePanel.prototype.PanelTitle = "";

    /**
     * BasePanel PanelContent.
     * @member {string} PanelContent
     * @memberof BasePanel
     * @instance
     */
    BasePanel.prototype.PanelContent = "";

    /**
     * BasePanel PanelRecommendedWidth.
     * @member {number} PanelRecommendedWidth
     * @memberof BasePanel
     * @instance
     */
    BasePanel.prototype.PanelRecommendedWidth = 0;

    /**
     * BasePanel PanelRecommendedHeight.
     * @member {number} PanelRecommendedHeight
     * @memberof BasePanel
     * @instance
     */
    BasePanel.prototype.PanelRecommendedHeight = 0;

    /**
     * BasePanel PanelMinWidth.
     * @member {number} PanelMinWidth
     * @memberof BasePanel
     * @instance
     */
    BasePanel.prototype.PanelMinWidth = 0;

    /**
     * BasePanel PanelMinHeight.
     * @member {number} PanelMinHeight
     * @memberof BasePanel
     * @instance
     */
    BasePanel.prototype.PanelMinHeight = 0;

    /**
     * BasePanel PanelMaxWidth.
     * @member {number} PanelMaxWidth
     * @memberof BasePanel
     * @instance
     */
    BasePanel.prototype.PanelMaxWidth = 0;

    /**
     * BasePanel PanelMaxHeight.
     * @member {number} PanelMaxHeight
     * @memberof BasePanel
     * @instance
     */
    BasePanel.prototype.PanelMaxHeight = 0;

    /**
     * BasePanel PanelRecommendedX.
     * @member {number} PanelRecommendedX
     * @memberof BasePanel
     * @instance
     */
    BasePanel.prototype.PanelRecommendedX = 0;

    /**
     * BasePanel PanelRecommendedY.
     * @member {number} PanelRecommendedY
     * @memberof BasePanel
     * @instance
     */
    BasePanel.prototype.PanelRecommendedY = 0;

    /**
     * BasePanel DefaultData.
     * @member {string} DefaultData
     * @memberof BasePanel
     * @instance
     */
    BasePanel.prototype.DefaultData = "";

    /**
     * BasePanel PanelIcon.
     * @member {string} PanelIcon
     * @memberof BasePanel
     * @instance
     */
    BasePanel.prototype.PanelIcon = "";

    /**
     * BasePanel AppClientID.
     * @member {string} AppClientID
     * @memberof BasePanel
     * @instance
     */
    BasePanel.prototype.AppClientID = "";

    /**
     * BasePanel FixedPanelID.
     * @member {string} FixedPanelID
     * @memberof BasePanel
     * @instance
     */
    BasePanel.prototype.FixedPanelID = "";

    /**
     * Creates a new BasePanel instance using the specified properties.
     * @function create
     * @memberof BasePanel
     * @static
     * @param {IBasePanel=} [properties] Properties to set
     * @returns {BasePanel} BasePanel instance
     */
    BasePanel.create = function create(properties) {
        return new BasePanel(properties);
    };

    /**
     * Encodes the specified BasePanel message. Does not implicitly {@link BasePanel.verify|verify} messages.
     * @function encode
     * @memberof BasePanel
     * @static
     * @param {IBasePanel} message BasePanel message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BasePanel.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.PanelType != null && Object.hasOwnProperty.call(message, "PanelType"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.PanelType);
        if (message.PanelTitle != null && Object.hasOwnProperty.call(message, "PanelTitle"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.PanelTitle);
        if (message.PanelContent != null && Object.hasOwnProperty.call(message, "PanelContent"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.PanelContent);
        if (message.PanelRecommendedWidth != null && Object.hasOwnProperty.call(message, "PanelRecommendedWidth"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.PanelRecommendedWidth);
        if (message.PanelRecommendedHeight != null && Object.hasOwnProperty.call(message, "PanelRecommendedHeight"))
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.PanelRecommendedHeight);
        if (message.PanelMinWidth != null && Object.hasOwnProperty.call(message, "PanelMinWidth"))
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.PanelMinWidth);
        if (message.PanelMinHeight != null && Object.hasOwnProperty.call(message, "PanelMinHeight"))
            writer.uint32(/* id 7, wireType 0 =*/56).int32(message.PanelMinHeight);
        if (message.PanelMaxWidth != null && Object.hasOwnProperty.call(message, "PanelMaxWidth"))
            writer.uint32(/* id 8, wireType 0 =*/64).int32(message.PanelMaxWidth);
        if (message.PanelMaxHeight != null && Object.hasOwnProperty.call(message, "PanelMaxHeight"))
            writer.uint32(/* id 9, wireType 0 =*/72).int32(message.PanelMaxHeight);
        if (message.PanelRecommendedX != null && Object.hasOwnProperty.call(message, "PanelRecommendedX"))
            writer.uint32(/* id 10, wireType 0 =*/80).int32(message.PanelRecommendedX);
        if (message.PanelRecommendedY != null && Object.hasOwnProperty.call(message, "PanelRecommendedY"))
            writer.uint32(/* id 11, wireType 0 =*/88).int32(message.PanelRecommendedY);
        if (message.DefaultData != null && Object.hasOwnProperty.call(message, "DefaultData"))
            writer.uint32(/* id 12, wireType 2 =*/98).string(message.DefaultData);
        if (message.PanelIcon != null && Object.hasOwnProperty.call(message, "PanelIcon"))
            writer.uint32(/* id 13, wireType 2 =*/106).string(message.PanelIcon);
        if (message.AppClientID != null && Object.hasOwnProperty.call(message, "AppClientID"))
            writer.uint32(/* id 14, wireType 2 =*/114).string(message.AppClientID);
        if (message.FixedPanelID != null && Object.hasOwnProperty.call(message, "FixedPanelID"))
            writer.uint32(/* id 15, wireType 2 =*/122).string(message.FixedPanelID);
        return writer;
    };

    /**
     * Encodes the specified BasePanel message, length delimited. Does not implicitly {@link BasePanel.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BasePanel
     * @static
     * @param {IBasePanel} message BasePanel message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BasePanel.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BasePanel message from the specified reader or buffer.
     * @function decode
     * @memberof BasePanel
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BasePanel} BasePanel
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BasePanel.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BasePanel();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.PanelType = reader.string();
                    break;
                }
            case 2: {
                    message.PanelTitle = reader.string();
                    break;
                }
            case 3: {
                    message.PanelContent = reader.string();
                    break;
                }
            case 4: {
                    message.PanelRecommendedWidth = reader.int32();
                    break;
                }
            case 5: {
                    message.PanelRecommendedHeight = reader.int32();
                    break;
                }
            case 6: {
                    message.PanelMinWidth = reader.int32();
                    break;
                }
            case 7: {
                    message.PanelMinHeight = reader.int32();
                    break;
                }
            case 8: {
                    message.PanelMaxWidth = reader.int32();
                    break;
                }
            case 9: {
                    message.PanelMaxHeight = reader.int32();
                    break;
                }
            case 10: {
                    message.PanelRecommendedX = reader.int32();
                    break;
                }
            case 11: {
                    message.PanelRecommendedY = reader.int32();
                    break;
                }
            case 12: {
                    message.DefaultData = reader.string();
                    break;
                }
            case 13: {
                    message.PanelIcon = reader.string();
                    break;
                }
            case 14: {
                    message.AppClientID = reader.string();
                    break;
                }
            case 15: {
                    message.FixedPanelID = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BasePanel message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BasePanel
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BasePanel} BasePanel
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BasePanel.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BasePanel message.
     * @function verify
     * @memberof BasePanel
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BasePanel.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.PanelType != null && message.hasOwnProperty("PanelType"))
            if (!$util.isString(message.PanelType))
                return "PanelType: string expected";
        if (message.PanelTitle != null && message.hasOwnProperty("PanelTitle"))
            if (!$util.isString(message.PanelTitle))
                return "PanelTitle: string expected";
        if (message.PanelContent != null && message.hasOwnProperty("PanelContent"))
            if (!$util.isString(message.PanelContent))
                return "PanelContent: string expected";
        if (message.PanelRecommendedWidth != null && message.hasOwnProperty("PanelRecommendedWidth"))
            if (!$util.isInteger(message.PanelRecommendedWidth))
                return "PanelRecommendedWidth: integer expected";
        if (message.PanelRecommendedHeight != null && message.hasOwnProperty("PanelRecommendedHeight"))
            if (!$util.isInteger(message.PanelRecommendedHeight))
                return "PanelRecommendedHeight: integer expected";
        if (message.PanelMinWidth != null && message.hasOwnProperty("PanelMinWidth"))
            if (!$util.isInteger(message.PanelMinWidth))
                return "PanelMinWidth: integer expected";
        if (message.PanelMinHeight != null && message.hasOwnProperty("PanelMinHeight"))
            if (!$util.isInteger(message.PanelMinHeight))
                return "PanelMinHeight: integer expected";
        if (message.PanelMaxWidth != null && message.hasOwnProperty("PanelMaxWidth"))
            if (!$util.isInteger(message.PanelMaxWidth))
                return "PanelMaxWidth: integer expected";
        if (message.PanelMaxHeight != null && message.hasOwnProperty("PanelMaxHeight"))
            if (!$util.isInteger(message.PanelMaxHeight))
                return "PanelMaxHeight: integer expected";
        if (message.PanelRecommendedX != null && message.hasOwnProperty("PanelRecommendedX"))
            if (!$util.isInteger(message.PanelRecommendedX))
                return "PanelRecommendedX: integer expected";
        if (message.PanelRecommendedY != null && message.hasOwnProperty("PanelRecommendedY"))
            if (!$util.isInteger(message.PanelRecommendedY))
                return "PanelRecommendedY: integer expected";
        if (message.DefaultData != null && message.hasOwnProperty("DefaultData"))
            if (!$util.isString(message.DefaultData))
                return "DefaultData: string expected";
        if (message.PanelIcon != null && message.hasOwnProperty("PanelIcon"))
            if (!$util.isString(message.PanelIcon))
                return "PanelIcon: string expected";
        if (message.AppClientID != null && message.hasOwnProperty("AppClientID"))
            if (!$util.isString(message.AppClientID))
                return "AppClientID: string expected";
        if (message.FixedPanelID != null && message.hasOwnProperty("FixedPanelID"))
            if (!$util.isString(message.FixedPanelID))
                return "FixedPanelID: string expected";
        return null;
    };

    /**
     * Creates a BasePanel message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BasePanel
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BasePanel} BasePanel
     */
    BasePanel.fromObject = function fromObject(object) {
        if (object instanceof $root.BasePanel)
            return object;
        let message = new $root.BasePanel();
        if (object.PanelType != null)
            message.PanelType = String(object.PanelType);
        if (object.PanelTitle != null)
            message.PanelTitle = String(object.PanelTitle);
        if (object.PanelContent != null)
            message.PanelContent = String(object.PanelContent);
        if (object.PanelRecommendedWidth != null)
            message.PanelRecommendedWidth = object.PanelRecommendedWidth | 0;
        if (object.PanelRecommendedHeight != null)
            message.PanelRecommendedHeight = object.PanelRecommendedHeight | 0;
        if (object.PanelMinWidth != null)
            message.PanelMinWidth = object.PanelMinWidth | 0;
        if (object.PanelMinHeight != null)
            message.PanelMinHeight = object.PanelMinHeight | 0;
        if (object.PanelMaxWidth != null)
            message.PanelMaxWidth = object.PanelMaxWidth | 0;
        if (object.PanelMaxHeight != null)
            message.PanelMaxHeight = object.PanelMaxHeight | 0;
        if (object.PanelRecommendedX != null)
            message.PanelRecommendedX = object.PanelRecommendedX | 0;
        if (object.PanelRecommendedY != null)
            message.PanelRecommendedY = object.PanelRecommendedY | 0;
        if (object.DefaultData != null)
            message.DefaultData = String(object.DefaultData);
        if (object.PanelIcon != null)
            message.PanelIcon = String(object.PanelIcon);
        if (object.AppClientID != null)
            message.AppClientID = String(object.AppClientID);
        if (object.FixedPanelID != null)
            message.FixedPanelID = String(object.FixedPanelID);
        return message;
    };

    /**
     * Creates a plain object from a BasePanel message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BasePanel
     * @static
     * @param {BasePanel} message BasePanel
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BasePanel.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.PanelType = "";
            object.PanelTitle = "";
            object.PanelContent = "";
            object.PanelRecommendedWidth = 0;
            object.PanelRecommendedHeight = 0;
            object.PanelMinWidth = 0;
            object.PanelMinHeight = 0;
            object.PanelMaxWidth = 0;
            object.PanelMaxHeight = 0;
            object.PanelRecommendedX = 0;
            object.PanelRecommendedY = 0;
            object.DefaultData = "";
            object.PanelIcon = "";
            object.AppClientID = "";
            object.FixedPanelID = "";
        }
        if (message.PanelType != null && message.hasOwnProperty("PanelType"))
            object.PanelType = message.PanelType;
        if (message.PanelTitle != null && message.hasOwnProperty("PanelTitle"))
            object.PanelTitle = message.PanelTitle;
        if (message.PanelContent != null && message.hasOwnProperty("PanelContent"))
            object.PanelContent = message.PanelContent;
        if (message.PanelRecommendedWidth != null && message.hasOwnProperty("PanelRecommendedWidth"))
            object.PanelRecommendedWidth = message.PanelRecommendedWidth;
        if (message.PanelRecommendedHeight != null && message.hasOwnProperty("PanelRecommendedHeight"))
            object.PanelRecommendedHeight = message.PanelRecommendedHeight;
        if (message.PanelMinWidth != null && message.hasOwnProperty("PanelMinWidth"))
            object.PanelMinWidth = message.PanelMinWidth;
        if (message.PanelMinHeight != null && message.hasOwnProperty("PanelMinHeight"))
            object.PanelMinHeight = message.PanelMinHeight;
        if (message.PanelMaxWidth != null && message.hasOwnProperty("PanelMaxWidth"))
            object.PanelMaxWidth = message.PanelMaxWidth;
        if (message.PanelMaxHeight != null && message.hasOwnProperty("PanelMaxHeight"))
            object.PanelMaxHeight = message.PanelMaxHeight;
        if (message.PanelRecommendedX != null && message.hasOwnProperty("PanelRecommendedX"))
            object.PanelRecommendedX = message.PanelRecommendedX;
        if (message.PanelRecommendedY != null && message.hasOwnProperty("PanelRecommendedY"))
            object.PanelRecommendedY = message.PanelRecommendedY;
        if (message.DefaultData != null && message.hasOwnProperty("DefaultData"))
            object.DefaultData = message.DefaultData;
        if (message.PanelIcon != null && message.hasOwnProperty("PanelIcon"))
            object.PanelIcon = message.PanelIcon;
        if (message.AppClientID != null && message.hasOwnProperty("AppClientID"))
            object.AppClientID = message.AppClientID;
        if (message.FixedPanelID != null && message.hasOwnProperty("FixedPanelID"))
            object.FixedPanelID = message.FixedPanelID;
        return object;
    };

    /**
     * Converts this BasePanel to JSON.
     * @function toJSON
     * @memberof BasePanel
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BasePanel.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for BasePanel
     * @function getTypeUrl
     * @memberof BasePanel
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    BasePanel.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/BasePanel";
    };

    return BasePanel;
})();

export const RuntimePanel = $root.RuntimePanel = (() => {

    /**
     * Properties of a RuntimePanel.
     * @exports IRuntimePanel
     * @interface IRuntimePanel
     * @property {IBasePanel|null} [basePanel] RuntimePanel basePanel
     * @property {string|null} [PersistentData] RuntimePanel PersistentData
     * @property {string|null} [UniquePanelID] RuntimePanel UniquePanelID
     * @property {number|null} [ControlPort] RuntimePanel ControlPort
     * @property {boolean|null} [Deleted] RuntimePanel Deleted
     */

    /**
     * Constructs a new RuntimePanel.
     * @exports RuntimePanel
     * @classdesc Represents a RuntimePanel.
     * @implements IRuntimePanel
     * @constructor
     * @param {IRuntimePanel=} [properties] Properties to set
     */
    function RuntimePanel(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * RuntimePanel basePanel.
     * @member {IBasePanel|null|undefined} basePanel
     * @memberof RuntimePanel
     * @instance
     */
    RuntimePanel.prototype.basePanel = null;

    /**
     * RuntimePanel PersistentData.
     * @member {string} PersistentData
     * @memberof RuntimePanel
     * @instance
     */
    RuntimePanel.prototype.PersistentData = "";

    /**
     * RuntimePanel UniquePanelID.
     * @member {string} UniquePanelID
     * @memberof RuntimePanel
     * @instance
     */
    RuntimePanel.prototype.UniquePanelID = "";

    /**
     * RuntimePanel ControlPort.
     * @member {number} ControlPort
     * @memberof RuntimePanel
     * @instance
     */
    RuntimePanel.prototype.ControlPort = 0;

    /**
     * RuntimePanel Deleted.
     * @member {boolean} Deleted
     * @memberof RuntimePanel
     * @instance
     */
    RuntimePanel.prototype.Deleted = false;

    /**
     * Creates a new RuntimePanel instance using the specified properties.
     * @function create
     * @memberof RuntimePanel
     * @static
     * @param {IRuntimePanel=} [properties] Properties to set
     * @returns {RuntimePanel} RuntimePanel instance
     */
    RuntimePanel.create = function create(properties) {
        return new RuntimePanel(properties);
    };

    /**
     * Encodes the specified RuntimePanel message. Does not implicitly {@link RuntimePanel.verify|verify} messages.
     * @function encode
     * @memberof RuntimePanel
     * @static
     * @param {IRuntimePanel} message RuntimePanel message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RuntimePanel.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.basePanel != null && Object.hasOwnProperty.call(message, "basePanel"))
            $root.BasePanel.encode(message.basePanel, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.PersistentData != null && Object.hasOwnProperty.call(message, "PersistentData"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.PersistentData);
        if (message.UniquePanelID != null && Object.hasOwnProperty.call(message, "UniquePanelID"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.UniquePanelID);
        if (message.ControlPort != null && Object.hasOwnProperty.call(message, "ControlPort"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.ControlPort);
        if (message.Deleted != null && Object.hasOwnProperty.call(message, "Deleted"))
            writer.uint32(/* id 5, wireType 0 =*/40).bool(message.Deleted);
        return writer;
    };

    /**
     * Encodes the specified RuntimePanel message, length delimited. Does not implicitly {@link RuntimePanel.verify|verify} messages.
     * @function encodeDelimited
     * @memberof RuntimePanel
     * @static
     * @param {IRuntimePanel} message RuntimePanel message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RuntimePanel.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RuntimePanel message from the specified reader or buffer.
     * @function decode
     * @memberof RuntimePanel
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {RuntimePanel} RuntimePanel
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RuntimePanel.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RuntimePanel();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.basePanel = $root.BasePanel.decode(reader, reader.uint32());
                    break;
                }
            case 2: {
                    message.PersistentData = reader.string();
                    break;
                }
            case 3: {
                    message.UniquePanelID = reader.string();
                    break;
                }
            case 4: {
                    message.ControlPort = reader.int32();
                    break;
                }
            case 5: {
                    message.Deleted = reader.bool();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a RuntimePanel message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof RuntimePanel
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {RuntimePanel} RuntimePanel
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RuntimePanel.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RuntimePanel message.
     * @function verify
     * @memberof RuntimePanel
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RuntimePanel.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.basePanel != null && message.hasOwnProperty("basePanel")) {
            let error = $root.BasePanel.verify(message.basePanel);
            if (error)
                return "basePanel." + error;
        }
        if (message.PersistentData != null && message.hasOwnProperty("PersistentData"))
            if (!$util.isString(message.PersistentData))
                return "PersistentData: string expected";
        if (message.UniquePanelID != null && message.hasOwnProperty("UniquePanelID"))
            if (!$util.isString(message.UniquePanelID))
                return "UniquePanelID: string expected";
        if (message.ControlPort != null && message.hasOwnProperty("ControlPort"))
            if (!$util.isInteger(message.ControlPort))
                return "ControlPort: integer expected";
        if (message.Deleted != null && message.hasOwnProperty("Deleted"))
            if (typeof message.Deleted !== "boolean")
                return "Deleted: boolean expected";
        return null;
    };

    /**
     * Creates a RuntimePanel message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof RuntimePanel
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {RuntimePanel} RuntimePanel
     */
    RuntimePanel.fromObject = function fromObject(object) {
        if (object instanceof $root.RuntimePanel)
            return object;
        let message = new $root.RuntimePanel();
        if (object.basePanel != null) {
            if (typeof object.basePanel !== "object")
                throw TypeError(".RuntimePanel.basePanel: object expected");
            message.basePanel = $root.BasePanel.fromObject(object.basePanel);
        }
        if (object.PersistentData != null)
            message.PersistentData = String(object.PersistentData);
        if (object.UniquePanelID != null)
            message.UniquePanelID = String(object.UniquePanelID);
        if (object.ControlPort != null)
            message.ControlPort = object.ControlPort | 0;
        if (object.Deleted != null)
            message.Deleted = Boolean(object.Deleted);
        return message;
    };

    /**
     * Creates a plain object from a RuntimePanel message. Also converts values to other types if specified.
     * @function toObject
     * @memberof RuntimePanel
     * @static
     * @param {RuntimePanel} message RuntimePanel
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RuntimePanel.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.basePanel = null;
            object.PersistentData = "";
            object.UniquePanelID = "";
            object.ControlPort = 0;
            object.Deleted = false;
        }
        if (message.basePanel != null && message.hasOwnProperty("basePanel"))
            object.basePanel = $root.BasePanel.toObject(message.basePanel, options);
        if (message.PersistentData != null && message.hasOwnProperty("PersistentData"))
            object.PersistentData = message.PersistentData;
        if (message.UniquePanelID != null && message.hasOwnProperty("UniquePanelID"))
            object.UniquePanelID = message.UniquePanelID;
        if (message.ControlPort != null && message.hasOwnProperty("ControlPort"))
            object.ControlPort = message.ControlPort;
        if (message.Deleted != null && message.hasOwnProperty("Deleted"))
            object.Deleted = message.Deleted;
        return object;
    };

    /**
     * Converts this RuntimePanel to JSON.
     * @function toJSON
     * @memberof RuntimePanel
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RuntimePanel.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for RuntimePanel
     * @function getTypeUrl
     * @memberof RuntimePanel
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    RuntimePanel.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/RuntimePanel";
    };

    return RuntimePanel;
})();

export const BackgroundSystemInitialResponse = $root.BackgroundSystemInitialResponse = (() => {

    /**
     * Properties of a BackgroundSystemInitialResponse.
     * @exports IBackgroundSystemInitialResponse
     * @interface IBackgroundSystemInitialResponse
     * @property {Array.<IBaseBackground>|null} [templateBackgrounds] BackgroundSystemInitialResponse templateBackgrounds
     * @property {Array.<IRuntimeBackground>|null} [instancedButBlankBackgrounds] BackgroundSystemInitialResponse instancedButBlankBackgrounds
     * @property {Array.<IRuntimeBackground>|null} [instancedBackgroundsFromStorage] BackgroundSystemInitialResponse instancedBackgroundsFromStorage
     * @property {string|null} [LastActiveBackgroundID] BackgroundSystemInitialResponse LastActiveBackgroundID
     * @property {Array.<IRuntimeBackground>|null} [deletedInstancedBackgrounds] BackgroundSystemInitialResponse deletedInstancedBackgrounds
     */

    /**
     * Constructs a new BackgroundSystemInitialResponse.
     * @exports BackgroundSystemInitialResponse
     * @classdesc Represents a BackgroundSystemInitialResponse.
     * @implements IBackgroundSystemInitialResponse
     * @constructor
     * @param {IBackgroundSystemInitialResponse=} [properties] Properties to set
     */
    function BackgroundSystemInitialResponse(properties) {
        this.templateBackgrounds = [];
        this.instancedButBlankBackgrounds = [];
        this.instancedBackgroundsFromStorage = [];
        this.deletedInstancedBackgrounds = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BackgroundSystemInitialResponse templateBackgrounds.
     * @member {Array.<IBaseBackground>} templateBackgrounds
     * @memberof BackgroundSystemInitialResponse
     * @instance
     */
    BackgroundSystemInitialResponse.prototype.templateBackgrounds = $util.emptyArray;

    /**
     * BackgroundSystemInitialResponse instancedButBlankBackgrounds.
     * @member {Array.<IRuntimeBackground>} instancedButBlankBackgrounds
     * @memberof BackgroundSystemInitialResponse
     * @instance
     */
    BackgroundSystemInitialResponse.prototype.instancedButBlankBackgrounds = $util.emptyArray;

    /**
     * BackgroundSystemInitialResponse instancedBackgroundsFromStorage.
     * @member {Array.<IRuntimeBackground>} instancedBackgroundsFromStorage
     * @memberof BackgroundSystemInitialResponse
     * @instance
     */
    BackgroundSystemInitialResponse.prototype.instancedBackgroundsFromStorage = $util.emptyArray;

    /**
     * BackgroundSystemInitialResponse LastActiveBackgroundID.
     * @member {string} LastActiveBackgroundID
     * @memberof BackgroundSystemInitialResponse
     * @instance
     */
    BackgroundSystemInitialResponse.prototype.LastActiveBackgroundID = "";

    /**
     * BackgroundSystemInitialResponse deletedInstancedBackgrounds.
     * @member {Array.<IRuntimeBackground>} deletedInstancedBackgrounds
     * @memberof BackgroundSystemInitialResponse
     * @instance
     */
    BackgroundSystemInitialResponse.prototype.deletedInstancedBackgrounds = $util.emptyArray;

    /**
     * Creates a new BackgroundSystemInitialResponse instance using the specified properties.
     * @function create
     * @memberof BackgroundSystemInitialResponse
     * @static
     * @param {IBackgroundSystemInitialResponse=} [properties] Properties to set
     * @returns {BackgroundSystemInitialResponse} BackgroundSystemInitialResponse instance
     */
    BackgroundSystemInitialResponse.create = function create(properties) {
        return new BackgroundSystemInitialResponse(properties);
    };

    /**
     * Encodes the specified BackgroundSystemInitialResponse message. Does not implicitly {@link BackgroundSystemInitialResponse.verify|verify} messages.
     * @function encode
     * @memberof BackgroundSystemInitialResponse
     * @static
     * @param {IBackgroundSystemInitialResponse} message BackgroundSystemInitialResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BackgroundSystemInitialResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.templateBackgrounds != null && message.templateBackgrounds.length)
            for (let i = 0; i < message.templateBackgrounds.length; ++i)
                $root.BaseBackground.encode(message.templateBackgrounds[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.instancedButBlankBackgrounds != null && message.instancedButBlankBackgrounds.length)
            for (let i = 0; i < message.instancedButBlankBackgrounds.length; ++i)
                $root.RuntimeBackground.encode(message.instancedButBlankBackgrounds[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.instancedBackgroundsFromStorage != null && message.instancedBackgroundsFromStorage.length)
            for (let i = 0; i < message.instancedBackgroundsFromStorage.length; ++i)
                $root.RuntimeBackground.encode(message.instancedBackgroundsFromStorage[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.LastActiveBackgroundID != null && Object.hasOwnProperty.call(message, "LastActiveBackgroundID"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.LastActiveBackgroundID);
        if (message.deletedInstancedBackgrounds != null && message.deletedInstancedBackgrounds.length)
            for (let i = 0; i < message.deletedInstancedBackgrounds.length; ++i)
                $root.RuntimeBackground.encode(message.deletedInstancedBackgrounds[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified BackgroundSystemInitialResponse message, length delimited. Does not implicitly {@link BackgroundSystemInitialResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BackgroundSystemInitialResponse
     * @static
     * @param {IBackgroundSystemInitialResponse} message BackgroundSystemInitialResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BackgroundSystemInitialResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BackgroundSystemInitialResponse message from the specified reader or buffer.
     * @function decode
     * @memberof BackgroundSystemInitialResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BackgroundSystemInitialResponse} BackgroundSystemInitialResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BackgroundSystemInitialResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BackgroundSystemInitialResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    if (!(message.templateBackgrounds && message.templateBackgrounds.length))
                        message.templateBackgrounds = [];
                    message.templateBackgrounds.push($root.BaseBackground.decode(reader, reader.uint32()));
                    break;
                }
            case 2: {
                    if (!(message.instancedButBlankBackgrounds && message.instancedButBlankBackgrounds.length))
                        message.instancedButBlankBackgrounds = [];
                    message.instancedButBlankBackgrounds.push($root.RuntimeBackground.decode(reader, reader.uint32()));
                    break;
                }
            case 3: {
                    if (!(message.instancedBackgroundsFromStorage && message.instancedBackgroundsFromStorage.length))
                        message.instancedBackgroundsFromStorage = [];
                    message.instancedBackgroundsFromStorage.push($root.RuntimeBackground.decode(reader, reader.uint32()));
                    break;
                }
            case 4: {
                    message.LastActiveBackgroundID = reader.string();
                    break;
                }
            case 5: {
                    if (!(message.deletedInstancedBackgrounds && message.deletedInstancedBackgrounds.length))
                        message.deletedInstancedBackgrounds = [];
                    message.deletedInstancedBackgrounds.push($root.RuntimeBackground.decode(reader, reader.uint32()));
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BackgroundSystemInitialResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BackgroundSystemInitialResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BackgroundSystemInitialResponse} BackgroundSystemInitialResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BackgroundSystemInitialResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BackgroundSystemInitialResponse message.
     * @function verify
     * @memberof BackgroundSystemInitialResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BackgroundSystemInitialResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.templateBackgrounds != null && message.hasOwnProperty("templateBackgrounds")) {
            if (!Array.isArray(message.templateBackgrounds))
                return "templateBackgrounds: array expected";
            for (let i = 0; i < message.templateBackgrounds.length; ++i) {
                let error = $root.BaseBackground.verify(message.templateBackgrounds[i]);
                if (error)
                    return "templateBackgrounds." + error;
            }
        }
        if (message.instancedButBlankBackgrounds != null && message.hasOwnProperty("instancedButBlankBackgrounds")) {
            if (!Array.isArray(message.instancedButBlankBackgrounds))
                return "instancedButBlankBackgrounds: array expected";
            for (let i = 0; i < message.instancedButBlankBackgrounds.length; ++i) {
                let error = $root.RuntimeBackground.verify(message.instancedButBlankBackgrounds[i]);
                if (error)
                    return "instancedButBlankBackgrounds." + error;
            }
        }
        if (message.instancedBackgroundsFromStorage != null && message.hasOwnProperty("instancedBackgroundsFromStorage")) {
            if (!Array.isArray(message.instancedBackgroundsFromStorage))
                return "instancedBackgroundsFromStorage: array expected";
            for (let i = 0; i < message.instancedBackgroundsFromStorage.length; ++i) {
                let error = $root.RuntimeBackground.verify(message.instancedBackgroundsFromStorage[i]);
                if (error)
                    return "instancedBackgroundsFromStorage." + error;
            }
        }
        if (message.LastActiveBackgroundID != null && message.hasOwnProperty("LastActiveBackgroundID"))
            if (!$util.isString(message.LastActiveBackgroundID))
                return "LastActiveBackgroundID: string expected";
        if (message.deletedInstancedBackgrounds != null && message.hasOwnProperty("deletedInstancedBackgrounds")) {
            if (!Array.isArray(message.deletedInstancedBackgrounds))
                return "deletedInstancedBackgrounds: array expected";
            for (let i = 0; i < message.deletedInstancedBackgrounds.length; ++i) {
                let error = $root.RuntimeBackground.verify(message.deletedInstancedBackgrounds[i]);
                if (error)
                    return "deletedInstancedBackgrounds." + error;
            }
        }
        return null;
    };

    /**
     * Creates a BackgroundSystemInitialResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BackgroundSystemInitialResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BackgroundSystemInitialResponse} BackgroundSystemInitialResponse
     */
    BackgroundSystemInitialResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.BackgroundSystemInitialResponse)
            return object;
        let message = new $root.BackgroundSystemInitialResponse();
        if (object.templateBackgrounds) {
            if (!Array.isArray(object.templateBackgrounds))
                throw TypeError(".BackgroundSystemInitialResponse.templateBackgrounds: array expected");
            message.templateBackgrounds = [];
            for (let i = 0; i < object.templateBackgrounds.length; ++i) {
                if (typeof object.templateBackgrounds[i] !== "object")
                    throw TypeError(".BackgroundSystemInitialResponse.templateBackgrounds: object expected");
                message.templateBackgrounds[i] = $root.BaseBackground.fromObject(object.templateBackgrounds[i]);
            }
        }
        if (object.instancedButBlankBackgrounds) {
            if (!Array.isArray(object.instancedButBlankBackgrounds))
                throw TypeError(".BackgroundSystemInitialResponse.instancedButBlankBackgrounds: array expected");
            message.instancedButBlankBackgrounds = [];
            for (let i = 0; i < object.instancedButBlankBackgrounds.length; ++i) {
                if (typeof object.instancedButBlankBackgrounds[i] !== "object")
                    throw TypeError(".BackgroundSystemInitialResponse.instancedButBlankBackgrounds: object expected");
                message.instancedButBlankBackgrounds[i] = $root.RuntimeBackground.fromObject(object.instancedButBlankBackgrounds[i]);
            }
        }
        if (object.instancedBackgroundsFromStorage) {
            if (!Array.isArray(object.instancedBackgroundsFromStorage))
                throw TypeError(".BackgroundSystemInitialResponse.instancedBackgroundsFromStorage: array expected");
            message.instancedBackgroundsFromStorage = [];
            for (let i = 0; i < object.instancedBackgroundsFromStorage.length; ++i) {
                if (typeof object.instancedBackgroundsFromStorage[i] !== "object")
                    throw TypeError(".BackgroundSystemInitialResponse.instancedBackgroundsFromStorage: object expected");
                message.instancedBackgroundsFromStorage[i] = $root.RuntimeBackground.fromObject(object.instancedBackgroundsFromStorage[i]);
            }
        }
        if (object.LastActiveBackgroundID != null)
            message.LastActiveBackgroundID = String(object.LastActiveBackgroundID);
        if (object.deletedInstancedBackgrounds) {
            if (!Array.isArray(object.deletedInstancedBackgrounds))
                throw TypeError(".BackgroundSystemInitialResponse.deletedInstancedBackgrounds: array expected");
            message.deletedInstancedBackgrounds = [];
            for (let i = 0; i < object.deletedInstancedBackgrounds.length; ++i) {
                if (typeof object.deletedInstancedBackgrounds[i] !== "object")
                    throw TypeError(".BackgroundSystemInitialResponse.deletedInstancedBackgrounds: object expected");
                message.deletedInstancedBackgrounds[i] = $root.RuntimeBackground.fromObject(object.deletedInstancedBackgrounds[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a BackgroundSystemInitialResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BackgroundSystemInitialResponse
     * @static
     * @param {BackgroundSystemInitialResponse} message BackgroundSystemInitialResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BackgroundSystemInitialResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults) {
            object.templateBackgrounds = [];
            object.instancedButBlankBackgrounds = [];
            object.instancedBackgroundsFromStorage = [];
            object.deletedInstancedBackgrounds = [];
        }
        if (options.defaults)
            object.LastActiveBackgroundID = "";
        if (message.templateBackgrounds && message.templateBackgrounds.length) {
            object.templateBackgrounds = [];
            for (let j = 0; j < message.templateBackgrounds.length; ++j)
                object.templateBackgrounds[j] = $root.BaseBackground.toObject(message.templateBackgrounds[j], options);
        }
        if (message.instancedButBlankBackgrounds && message.instancedButBlankBackgrounds.length) {
            object.instancedButBlankBackgrounds = [];
            for (let j = 0; j < message.instancedButBlankBackgrounds.length; ++j)
                object.instancedButBlankBackgrounds[j] = $root.RuntimeBackground.toObject(message.instancedButBlankBackgrounds[j], options);
        }
        if (message.instancedBackgroundsFromStorage && message.instancedBackgroundsFromStorage.length) {
            object.instancedBackgroundsFromStorage = [];
            for (let j = 0; j < message.instancedBackgroundsFromStorage.length; ++j)
                object.instancedBackgroundsFromStorage[j] = $root.RuntimeBackground.toObject(message.instancedBackgroundsFromStorage[j], options);
        }
        if (message.LastActiveBackgroundID != null && message.hasOwnProperty("LastActiveBackgroundID"))
            object.LastActiveBackgroundID = message.LastActiveBackgroundID;
        if (message.deletedInstancedBackgrounds && message.deletedInstancedBackgrounds.length) {
            object.deletedInstancedBackgrounds = [];
            for (let j = 0; j < message.deletedInstancedBackgrounds.length; ++j)
                object.deletedInstancedBackgrounds[j] = $root.RuntimeBackground.toObject(message.deletedInstancedBackgrounds[j], options);
        }
        return object;
    };

    /**
     * Converts this BackgroundSystemInitialResponse to JSON.
     * @function toJSON
     * @memberof BackgroundSystemInitialResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BackgroundSystemInitialResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for BackgroundSystemInitialResponse
     * @function getTypeUrl
     * @memberof BackgroundSystemInitialResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    BackgroundSystemInitialResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/BackgroundSystemInitialResponse";
    };

    return BackgroundSystemInitialResponse;
})();

export const BaseBackground = $root.BaseBackground = (() => {

    /**
     * Properties of a BaseBackground.
     * @exports IBaseBackground
     * @interface IBaseBackground
     * @property {string|null} [BackgroundType] BaseBackground BackgroundType
     * @property {string|null} [FixedBackgroundID] BaseBackground FixedBackgroundID
     * @property {string|null} [BackgroundContent] BaseBackground BackgroundContent
     * @property {string|null} [BackgroundDefaultData] BaseBackground BackgroundDefaultData
     * @property {string|null} [AppClientID] BaseBackground AppClientID
     */

    /**
     * Constructs a new BaseBackground.
     * @exports BaseBackground
     * @classdesc Represents a BaseBackground.
     * @implements IBaseBackground
     * @constructor
     * @param {IBaseBackground=} [properties] Properties to set
     */
    function BaseBackground(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BaseBackground BackgroundType.
     * @member {string} BackgroundType
     * @memberof BaseBackground
     * @instance
     */
    BaseBackground.prototype.BackgroundType = "";

    /**
     * BaseBackground FixedBackgroundID.
     * @member {string} FixedBackgroundID
     * @memberof BaseBackground
     * @instance
     */
    BaseBackground.prototype.FixedBackgroundID = "";

    /**
     * BaseBackground BackgroundContent.
     * @member {string} BackgroundContent
     * @memberof BaseBackground
     * @instance
     */
    BaseBackground.prototype.BackgroundContent = "";

    /**
     * BaseBackground BackgroundDefaultData.
     * @member {string} BackgroundDefaultData
     * @memberof BaseBackground
     * @instance
     */
    BaseBackground.prototype.BackgroundDefaultData = "";

    /**
     * BaseBackground AppClientID.
     * @member {string} AppClientID
     * @memberof BaseBackground
     * @instance
     */
    BaseBackground.prototype.AppClientID = "";

    /**
     * Creates a new BaseBackground instance using the specified properties.
     * @function create
     * @memberof BaseBackground
     * @static
     * @param {IBaseBackground=} [properties] Properties to set
     * @returns {BaseBackground} BaseBackground instance
     */
    BaseBackground.create = function create(properties) {
        return new BaseBackground(properties);
    };

    /**
     * Encodes the specified BaseBackground message. Does not implicitly {@link BaseBackground.verify|verify} messages.
     * @function encode
     * @memberof BaseBackground
     * @static
     * @param {IBaseBackground} message BaseBackground message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BaseBackground.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.BackgroundType != null && Object.hasOwnProperty.call(message, "BackgroundType"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.BackgroundType);
        if (message.FixedBackgroundID != null && Object.hasOwnProperty.call(message, "FixedBackgroundID"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.FixedBackgroundID);
        if (message.BackgroundContent != null && Object.hasOwnProperty.call(message, "BackgroundContent"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.BackgroundContent);
        if (message.BackgroundDefaultData != null && Object.hasOwnProperty.call(message, "BackgroundDefaultData"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.BackgroundDefaultData);
        if (message.AppClientID != null && Object.hasOwnProperty.call(message, "AppClientID"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.AppClientID);
        return writer;
    };

    /**
     * Encodes the specified BaseBackground message, length delimited. Does not implicitly {@link BaseBackground.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BaseBackground
     * @static
     * @param {IBaseBackground} message BaseBackground message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BaseBackground.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BaseBackground message from the specified reader or buffer.
     * @function decode
     * @memberof BaseBackground
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BaseBackground} BaseBackground
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BaseBackground.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BaseBackground();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.BackgroundType = reader.string();
                    break;
                }
            case 2: {
                    message.FixedBackgroundID = reader.string();
                    break;
                }
            case 3: {
                    message.BackgroundContent = reader.string();
                    break;
                }
            case 4: {
                    message.BackgroundDefaultData = reader.string();
                    break;
                }
            case 5: {
                    message.AppClientID = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BaseBackground message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BaseBackground
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BaseBackground} BaseBackground
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BaseBackground.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BaseBackground message.
     * @function verify
     * @memberof BaseBackground
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BaseBackground.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.BackgroundType != null && message.hasOwnProperty("BackgroundType"))
            if (!$util.isString(message.BackgroundType))
                return "BackgroundType: string expected";
        if (message.FixedBackgroundID != null && message.hasOwnProperty("FixedBackgroundID"))
            if (!$util.isString(message.FixedBackgroundID))
                return "FixedBackgroundID: string expected";
        if (message.BackgroundContent != null && message.hasOwnProperty("BackgroundContent"))
            if (!$util.isString(message.BackgroundContent))
                return "BackgroundContent: string expected";
        if (message.BackgroundDefaultData != null && message.hasOwnProperty("BackgroundDefaultData"))
            if (!$util.isString(message.BackgroundDefaultData))
                return "BackgroundDefaultData: string expected";
        if (message.AppClientID != null && message.hasOwnProperty("AppClientID"))
            if (!$util.isString(message.AppClientID))
                return "AppClientID: string expected";
        return null;
    };

    /**
     * Creates a BaseBackground message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BaseBackground
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BaseBackground} BaseBackground
     */
    BaseBackground.fromObject = function fromObject(object) {
        if (object instanceof $root.BaseBackground)
            return object;
        let message = new $root.BaseBackground();
        if (object.BackgroundType != null)
            message.BackgroundType = String(object.BackgroundType);
        if (object.FixedBackgroundID != null)
            message.FixedBackgroundID = String(object.FixedBackgroundID);
        if (object.BackgroundContent != null)
            message.BackgroundContent = String(object.BackgroundContent);
        if (object.BackgroundDefaultData != null)
            message.BackgroundDefaultData = String(object.BackgroundDefaultData);
        if (object.AppClientID != null)
            message.AppClientID = String(object.AppClientID);
        return message;
    };

    /**
     * Creates a plain object from a BaseBackground message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BaseBackground
     * @static
     * @param {BaseBackground} message BaseBackground
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BaseBackground.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.BackgroundType = "";
            object.FixedBackgroundID = "";
            object.BackgroundContent = "";
            object.BackgroundDefaultData = "";
            object.AppClientID = "";
        }
        if (message.BackgroundType != null && message.hasOwnProperty("BackgroundType"))
            object.BackgroundType = message.BackgroundType;
        if (message.FixedBackgroundID != null && message.hasOwnProperty("FixedBackgroundID"))
            object.FixedBackgroundID = message.FixedBackgroundID;
        if (message.BackgroundContent != null && message.hasOwnProperty("BackgroundContent"))
            object.BackgroundContent = message.BackgroundContent;
        if (message.BackgroundDefaultData != null && message.hasOwnProperty("BackgroundDefaultData"))
            object.BackgroundDefaultData = message.BackgroundDefaultData;
        if (message.AppClientID != null && message.hasOwnProperty("AppClientID"))
            object.AppClientID = message.AppClientID;
        return object;
    };

    /**
     * Converts this BaseBackground to JSON.
     * @function toJSON
     * @memberof BaseBackground
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BaseBackground.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for BaseBackground
     * @function getTypeUrl
     * @memberof BaseBackground
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    BaseBackground.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/BaseBackground";
    };

    return BaseBackground;
})();

export const RuntimeBackground = $root.RuntimeBackground = (() => {

    /**
     * Properties of a RuntimeBackground.
     * @exports IRuntimeBackground
     * @interface IRuntimeBackground
     * @property {IBaseBackground|null} [baseBackground] RuntimeBackground baseBackground
     * @property {string|null} [PersistentData] RuntimeBackground PersistentData
     * @property {string|null} [UniqueBackgroundID] RuntimeBackground UniqueBackgroundID
     * @property {number|null} [ControlPort] RuntimeBackground ControlPort
     * @property {boolean|null} [Deleted] RuntimeBackground Deleted
     */

    /**
     * Constructs a new RuntimeBackground.
     * @exports RuntimeBackground
     * @classdesc Represents a RuntimeBackground.
     * @implements IRuntimeBackground
     * @constructor
     * @param {IRuntimeBackground=} [properties] Properties to set
     */
    function RuntimeBackground(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * RuntimeBackground baseBackground.
     * @member {IBaseBackground|null|undefined} baseBackground
     * @memberof RuntimeBackground
     * @instance
     */
    RuntimeBackground.prototype.baseBackground = null;

    /**
     * RuntimeBackground PersistentData.
     * @member {string} PersistentData
     * @memberof RuntimeBackground
     * @instance
     */
    RuntimeBackground.prototype.PersistentData = "";

    /**
     * RuntimeBackground UniqueBackgroundID.
     * @member {string} UniqueBackgroundID
     * @memberof RuntimeBackground
     * @instance
     */
    RuntimeBackground.prototype.UniqueBackgroundID = "";

    /**
     * RuntimeBackground ControlPort.
     * @member {number} ControlPort
     * @memberof RuntimeBackground
     * @instance
     */
    RuntimeBackground.prototype.ControlPort = 0;

    /**
     * RuntimeBackground Deleted.
     * @member {boolean} Deleted
     * @memberof RuntimeBackground
     * @instance
     */
    RuntimeBackground.prototype.Deleted = false;

    /**
     * Creates a new RuntimeBackground instance using the specified properties.
     * @function create
     * @memberof RuntimeBackground
     * @static
     * @param {IRuntimeBackground=} [properties] Properties to set
     * @returns {RuntimeBackground} RuntimeBackground instance
     */
    RuntimeBackground.create = function create(properties) {
        return new RuntimeBackground(properties);
    };

    /**
     * Encodes the specified RuntimeBackground message. Does not implicitly {@link RuntimeBackground.verify|verify} messages.
     * @function encode
     * @memberof RuntimeBackground
     * @static
     * @param {IRuntimeBackground} message RuntimeBackground message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RuntimeBackground.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.baseBackground != null && Object.hasOwnProperty.call(message, "baseBackground"))
            $root.BaseBackground.encode(message.baseBackground, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.PersistentData != null && Object.hasOwnProperty.call(message, "PersistentData"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.PersistentData);
        if (message.UniqueBackgroundID != null && Object.hasOwnProperty.call(message, "UniqueBackgroundID"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.UniqueBackgroundID);
        if (message.ControlPort != null && Object.hasOwnProperty.call(message, "ControlPort"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.ControlPort);
        if (message.Deleted != null && Object.hasOwnProperty.call(message, "Deleted"))
            writer.uint32(/* id 5, wireType 0 =*/40).bool(message.Deleted);
        return writer;
    };

    /**
     * Encodes the specified RuntimeBackground message, length delimited. Does not implicitly {@link RuntimeBackground.verify|verify} messages.
     * @function encodeDelimited
     * @memberof RuntimeBackground
     * @static
     * @param {IRuntimeBackground} message RuntimeBackground message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RuntimeBackground.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RuntimeBackground message from the specified reader or buffer.
     * @function decode
     * @memberof RuntimeBackground
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {RuntimeBackground} RuntimeBackground
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RuntimeBackground.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RuntimeBackground();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.baseBackground = $root.BaseBackground.decode(reader, reader.uint32());
                    break;
                }
            case 2: {
                    message.PersistentData = reader.string();
                    break;
                }
            case 3: {
                    message.UniqueBackgroundID = reader.string();
                    break;
                }
            case 4: {
                    message.ControlPort = reader.int32();
                    break;
                }
            case 5: {
                    message.Deleted = reader.bool();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a RuntimeBackground message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof RuntimeBackground
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {RuntimeBackground} RuntimeBackground
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RuntimeBackground.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RuntimeBackground message.
     * @function verify
     * @memberof RuntimeBackground
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RuntimeBackground.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.baseBackground != null && message.hasOwnProperty("baseBackground")) {
            let error = $root.BaseBackground.verify(message.baseBackground);
            if (error)
                return "baseBackground." + error;
        }
        if (message.PersistentData != null && message.hasOwnProperty("PersistentData"))
            if (!$util.isString(message.PersistentData))
                return "PersistentData: string expected";
        if (message.UniqueBackgroundID != null && message.hasOwnProperty("UniqueBackgroundID"))
            if (!$util.isString(message.UniqueBackgroundID))
                return "UniqueBackgroundID: string expected";
        if (message.ControlPort != null && message.hasOwnProperty("ControlPort"))
            if (!$util.isInteger(message.ControlPort))
                return "ControlPort: integer expected";
        if (message.Deleted != null && message.hasOwnProperty("Deleted"))
            if (typeof message.Deleted !== "boolean")
                return "Deleted: boolean expected";
        return null;
    };

    /**
     * Creates a RuntimeBackground message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof RuntimeBackground
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {RuntimeBackground} RuntimeBackground
     */
    RuntimeBackground.fromObject = function fromObject(object) {
        if (object instanceof $root.RuntimeBackground)
            return object;
        let message = new $root.RuntimeBackground();
        if (object.baseBackground != null) {
            if (typeof object.baseBackground !== "object")
                throw TypeError(".RuntimeBackground.baseBackground: object expected");
            message.baseBackground = $root.BaseBackground.fromObject(object.baseBackground);
        }
        if (object.PersistentData != null)
            message.PersistentData = String(object.PersistentData);
        if (object.UniqueBackgroundID != null)
            message.UniqueBackgroundID = String(object.UniqueBackgroundID);
        if (object.ControlPort != null)
            message.ControlPort = object.ControlPort | 0;
        if (object.Deleted != null)
            message.Deleted = Boolean(object.Deleted);
        return message;
    };

    /**
     * Creates a plain object from a RuntimeBackground message. Also converts values to other types if specified.
     * @function toObject
     * @memberof RuntimeBackground
     * @static
     * @param {RuntimeBackground} message RuntimeBackground
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RuntimeBackground.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.baseBackground = null;
            object.PersistentData = "";
            object.UniqueBackgroundID = "";
            object.ControlPort = 0;
            object.Deleted = false;
        }
        if (message.baseBackground != null && message.hasOwnProperty("baseBackground"))
            object.baseBackground = $root.BaseBackground.toObject(message.baseBackground, options);
        if (message.PersistentData != null && message.hasOwnProperty("PersistentData"))
            object.PersistentData = message.PersistentData;
        if (message.UniqueBackgroundID != null && message.hasOwnProperty("UniqueBackgroundID"))
            object.UniqueBackgroundID = message.UniqueBackgroundID;
        if (message.ControlPort != null && message.hasOwnProperty("ControlPort"))
            object.ControlPort = message.ControlPort;
        if (message.Deleted != null && message.hasOwnProperty("Deleted"))
            object.Deleted = message.Deleted;
        return object;
    };

    /**
     * Converts this RuntimeBackground to JSON.
     * @function toJSON
     * @memberof RuntimeBackground
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RuntimeBackground.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for RuntimeBackground
     * @function getTypeUrl
     * @memberof RuntimeBackground
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    RuntimeBackground.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/RuntimeBackground";
    };

    return RuntimeBackground;
})();

export const SimpleBackground = $root.SimpleBackground = (() => {

    /**
     * Properties of a SimpleBackground.
     * @exports ISimpleBackground
     * @interface ISimpleBackground
     * @property {string|null} [FilePath] SimpleBackground FilePath
     * @property {string|null} [OriginalFilePath] SimpleBackground OriginalFilePath
     * @property {number|Long|null} [TimestampAdded] SimpleBackground TimestampAdded
     */

    /**
     * Constructs a new SimpleBackground.
     * @exports SimpleBackground
     * @classdesc Represents a SimpleBackground.
     * @implements ISimpleBackground
     * @constructor
     * @param {ISimpleBackground=} [properties] Properties to set
     */
    function SimpleBackground(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SimpleBackground FilePath.
     * @member {string} FilePath
     * @memberof SimpleBackground
     * @instance
     */
    SimpleBackground.prototype.FilePath = "";

    /**
     * SimpleBackground OriginalFilePath.
     * @member {string} OriginalFilePath
     * @memberof SimpleBackground
     * @instance
     */
    SimpleBackground.prototype.OriginalFilePath = "";

    /**
     * SimpleBackground TimestampAdded.
     * @member {number|Long} TimestampAdded
     * @memberof SimpleBackground
     * @instance
     */
    SimpleBackground.prototype.TimestampAdded = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Creates a new SimpleBackground instance using the specified properties.
     * @function create
     * @memberof SimpleBackground
     * @static
     * @param {ISimpleBackground=} [properties] Properties to set
     * @returns {SimpleBackground} SimpleBackground instance
     */
    SimpleBackground.create = function create(properties) {
        return new SimpleBackground(properties);
    };

    /**
     * Encodes the specified SimpleBackground message. Does not implicitly {@link SimpleBackground.verify|verify} messages.
     * @function encode
     * @memberof SimpleBackground
     * @static
     * @param {ISimpleBackground} message SimpleBackground message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SimpleBackground.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.FilePath != null && Object.hasOwnProperty.call(message, "FilePath"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.FilePath);
        if (message.OriginalFilePath != null && Object.hasOwnProperty.call(message, "OriginalFilePath"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.OriginalFilePath);
        if (message.TimestampAdded != null && Object.hasOwnProperty.call(message, "TimestampAdded"))
            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.TimestampAdded);
        return writer;
    };

    /**
     * Encodes the specified SimpleBackground message, length delimited. Does not implicitly {@link SimpleBackground.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SimpleBackground
     * @static
     * @param {ISimpleBackground} message SimpleBackground message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SimpleBackground.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SimpleBackground message from the specified reader or buffer.
     * @function decode
     * @memberof SimpleBackground
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SimpleBackground} SimpleBackground
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SimpleBackground.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SimpleBackground();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.FilePath = reader.string();
                    break;
                }
            case 2: {
                    message.OriginalFilePath = reader.string();
                    break;
                }
            case 3: {
                    message.TimestampAdded = reader.int64();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SimpleBackground message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SimpleBackground
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SimpleBackground} SimpleBackground
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SimpleBackground.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SimpleBackground message.
     * @function verify
     * @memberof SimpleBackground
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SimpleBackground.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.FilePath != null && message.hasOwnProperty("FilePath"))
            if (!$util.isString(message.FilePath))
                return "FilePath: string expected";
        if (message.OriginalFilePath != null && message.hasOwnProperty("OriginalFilePath"))
            if (!$util.isString(message.OriginalFilePath))
                return "OriginalFilePath: string expected";
        if (message.TimestampAdded != null && message.hasOwnProperty("TimestampAdded"))
            if (!$util.isInteger(message.TimestampAdded) && !(message.TimestampAdded && $util.isInteger(message.TimestampAdded.low) && $util.isInteger(message.TimestampAdded.high)))
                return "TimestampAdded: integer|Long expected";
        return null;
    };

    /**
     * Creates a SimpleBackground message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SimpleBackground
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SimpleBackground} SimpleBackground
     */
    SimpleBackground.fromObject = function fromObject(object) {
        if (object instanceof $root.SimpleBackground)
            return object;
        let message = new $root.SimpleBackground();
        if (object.FilePath != null)
            message.FilePath = String(object.FilePath);
        if (object.OriginalFilePath != null)
            message.OriginalFilePath = String(object.OriginalFilePath);
        if (object.TimestampAdded != null)
            if ($util.Long)
                (message.TimestampAdded = $util.Long.fromValue(object.TimestampAdded)).unsigned = false;
            else if (typeof object.TimestampAdded === "string")
                message.TimestampAdded = parseInt(object.TimestampAdded, 10);
            else if (typeof object.TimestampAdded === "number")
                message.TimestampAdded = object.TimestampAdded;
            else if (typeof object.TimestampAdded === "object")
                message.TimestampAdded = new $util.LongBits(object.TimestampAdded.low >>> 0, object.TimestampAdded.high >>> 0).toNumber();
        return message;
    };

    /**
     * Creates a plain object from a SimpleBackground message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SimpleBackground
     * @static
     * @param {SimpleBackground} message SimpleBackground
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SimpleBackground.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.FilePath = "";
            object.OriginalFilePath = "";
            if ($util.Long) {
                let long = new $util.Long(0, 0, false);
                object.TimestampAdded = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.TimestampAdded = options.longs === String ? "0" : 0;
        }
        if (message.FilePath != null && message.hasOwnProperty("FilePath"))
            object.FilePath = message.FilePath;
        if (message.OriginalFilePath != null && message.hasOwnProperty("OriginalFilePath"))
            object.OriginalFilePath = message.OriginalFilePath;
        if (message.TimestampAdded != null && message.hasOwnProperty("TimestampAdded"))
            if (typeof message.TimestampAdded === "number")
                object.TimestampAdded = options.longs === String ? String(message.TimestampAdded) : message.TimestampAdded;
            else
                object.TimestampAdded = options.longs === String ? $util.Long.prototype.toString.call(message.TimestampAdded) : options.longs === Number ? new $util.LongBits(message.TimestampAdded.low >>> 0, message.TimestampAdded.high >>> 0).toNumber() : message.TimestampAdded;
        return object;
    };

    /**
     * Converts this SimpleBackground to JSON.
     * @function toJSON
     * @memberof SimpleBackground
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SimpleBackground.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for SimpleBackground
     * @function getTypeUrl
     * @memberof SimpleBackground
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    SimpleBackground.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/SimpleBackground";
    };

    return SimpleBackground;
})();

export const AddonManifest = $root.AddonManifest = (() => {

    /**
     * Properties of an AddonManifest.
     * @exports IAddonManifest
     * @interface IAddonManifest
     * @property {string|null} [AddonName] AddonManifest AddonName
     * @property {string|null} [AddonDescription] AddonManifest AddonDescription
     * @property {string|null} [AddonVersion] AddonManifest AddonVersion
     * @property {string|null} [AddonAuthor] AddonManifest AddonAuthor
     * @property {string|null} [AddonWebsite] AddonManifest AddonWebsite
     * @property {string|null} [AddonIcon] AddonManifest AddonIcon
     * @property {string|null} [AddonClientID] AddonManifest AddonClientID
     * @property {string|null} [AddonBootstrapEntryPoint] AddonManifest AddonBootstrapEntryPoint
     * @property {boolean|null} [AddonEnableAutoRestart] AddonManifest AddonEnableAutoRestart
     * @property {string|null} [AddonFolderName] AddonManifest AddonFolderName
     */

    /**
     * Constructs a new AddonManifest.
     * @exports AddonManifest
     * @classdesc Represents an AddonManifest.
     * @implements IAddonManifest
     * @constructor
     * @param {IAddonManifest=} [properties] Properties to set
     */
    function AddonManifest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * AddonManifest AddonName.
     * @member {string} AddonName
     * @memberof AddonManifest
     * @instance
     */
    AddonManifest.prototype.AddonName = "";

    /**
     * AddonManifest AddonDescription.
     * @member {string} AddonDescription
     * @memberof AddonManifest
     * @instance
     */
    AddonManifest.prototype.AddonDescription = "";

    /**
     * AddonManifest AddonVersion.
     * @member {string} AddonVersion
     * @memberof AddonManifest
     * @instance
     */
    AddonManifest.prototype.AddonVersion = "";

    /**
     * AddonManifest AddonAuthor.
     * @member {string} AddonAuthor
     * @memberof AddonManifest
     * @instance
     */
    AddonManifest.prototype.AddonAuthor = "";

    /**
     * AddonManifest AddonWebsite.
     * @member {string} AddonWebsite
     * @memberof AddonManifest
     * @instance
     */
    AddonManifest.prototype.AddonWebsite = "";

    /**
     * AddonManifest AddonIcon.
     * @member {string} AddonIcon
     * @memberof AddonManifest
     * @instance
     */
    AddonManifest.prototype.AddonIcon = "";

    /**
     * AddonManifest AddonClientID.
     * @member {string} AddonClientID
     * @memberof AddonManifest
     * @instance
     */
    AddonManifest.prototype.AddonClientID = "";

    /**
     * AddonManifest AddonBootstrapEntryPoint.
     * @member {string} AddonBootstrapEntryPoint
     * @memberof AddonManifest
     * @instance
     */
    AddonManifest.prototype.AddonBootstrapEntryPoint = "";

    /**
     * AddonManifest AddonEnableAutoRestart.
     * @member {boolean} AddonEnableAutoRestart
     * @memberof AddonManifest
     * @instance
     */
    AddonManifest.prototype.AddonEnableAutoRestart = false;

    /**
     * AddonManifest AddonFolderName.
     * @member {string} AddonFolderName
     * @memberof AddonManifest
     * @instance
     */
    AddonManifest.prototype.AddonFolderName = "";

    /**
     * Creates a new AddonManifest instance using the specified properties.
     * @function create
     * @memberof AddonManifest
     * @static
     * @param {IAddonManifest=} [properties] Properties to set
     * @returns {AddonManifest} AddonManifest instance
     */
    AddonManifest.create = function create(properties) {
        return new AddonManifest(properties);
    };

    /**
     * Encodes the specified AddonManifest message. Does not implicitly {@link AddonManifest.verify|verify} messages.
     * @function encode
     * @memberof AddonManifest
     * @static
     * @param {IAddonManifest} message AddonManifest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AddonManifest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.AddonName != null && Object.hasOwnProperty.call(message, "AddonName"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.AddonName);
        if (message.AddonDescription != null && Object.hasOwnProperty.call(message, "AddonDescription"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.AddonDescription);
        if (message.AddonVersion != null && Object.hasOwnProperty.call(message, "AddonVersion"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.AddonVersion);
        if (message.AddonAuthor != null && Object.hasOwnProperty.call(message, "AddonAuthor"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.AddonAuthor);
        if (message.AddonWebsite != null && Object.hasOwnProperty.call(message, "AddonWebsite"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.AddonWebsite);
        if (message.AddonIcon != null && Object.hasOwnProperty.call(message, "AddonIcon"))
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.AddonIcon);
        if (message.AddonClientID != null && Object.hasOwnProperty.call(message, "AddonClientID"))
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.AddonClientID);
        if (message.AddonBootstrapEntryPoint != null && Object.hasOwnProperty.call(message, "AddonBootstrapEntryPoint"))
            writer.uint32(/* id 8, wireType 2 =*/66).string(message.AddonBootstrapEntryPoint);
        if (message.AddonEnableAutoRestart != null && Object.hasOwnProperty.call(message, "AddonEnableAutoRestart"))
            writer.uint32(/* id 9, wireType 0 =*/72).bool(message.AddonEnableAutoRestart);
        if (message.AddonFolderName != null && Object.hasOwnProperty.call(message, "AddonFolderName"))
            writer.uint32(/* id 10, wireType 2 =*/82).string(message.AddonFolderName);
        return writer;
    };

    /**
     * Encodes the specified AddonManifest message, length delimited. Does not implicitly {@link AddonManifest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof AddonManifest
     * @static
     * @param {IAddonManifest} message AddonManifest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AddonManifest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AddonManifest message from the specified reader or buffer.
     * @function decode
     * @memberof AddonManifest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AddonManifest} AddonManifest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AddonManifest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AddonManifest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.AddonName = reader.string();
                    break;
                }
            case 2: {
                    message.AddonDescription = reader.string();
                    break;
                }
            case 3: {
                    message.AddonVersion = reader.string();
                    break;
                }
            case 4: {
                    message.AddonAuthor = reader.string();
                    break;
                }
            case 5: {
                    message.AddonWebsite = reader.string();
                    break;
                }
            case 6: {
                    message.AddonIcon = reader.string();
                    break;
                }
            case 7: {
                    message.AddonClientID = reader.string();
                    break;
                }
            case 8: {
                    message.AddonBootstrapEntryPoint = reader.string();
                    break;
                }
            case 9: {
                    message.AddonEnableAutoRestart = reader.bool();
                    break;
                }
            case 10: {
                    message.AddonFolderName = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an AddonManifest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof AddonManifest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {AddonManifest} AddonManifest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AddonManifest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AddonManifest message.
     * @function verify
     * @memberof AddonManifest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AddonManifest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.AddonName != null && message.hasOwnProperty("AddonName"))
            if (!$util.isString(message.AddonName))
                return "AddonName: string expected";
        if (message.AddonDescription != null && message.hasOwnProperty("AddonDescription"))
            if (!$util.isString(message.AddonDescription))
                return "AddonDescription: string expected";
        if (message.AddonVersion != null && message.hasOwnProperty("AddonVersion"))
            if (!$util.isString(message.AddonVersion))
                return "AddonVersion: string expected";
        if (message.AddonAuthor != null && message.hasOwnProperty("AddonAuthor"))
            if (!$util.isString(message.AddonAuthor))
                return "AddonAuthor: string expected";
        if (message.AddonWebsite != null && message.hasOwnProperty("AddonWebsite"))
            if (!$util.isString(message.AddonWebsite))
                return "AddonWebsite: string expected";
        if (message.AddonIcon != null && message.hasOwnProperty("AddonIcon"))
            if (!$util.isString(message.AddonIcon))
                return "AddonIcon: string expected";
        if (message.AddonClientID != null && message.hasOwnProperty("AddonClientID"))
            if (!$util.isString(message.AddonClientID))
                return "AddonClientID: string expected";
        if (message.AddonBootstrapEntryPoint != null && message.hasOwnProperty("AddonBootstrapEntryPoint"))
            if (!$util.isString(message.AddonBootstrapEntryPoint))
                return "AddonBootstrapEntryPoint: string expected";
        if (message.AddonEnableAutoRestart != null && message.hasOwnProperty("AddonEnableAutoRestart"))
            if (typeof message.AddonEnableAutoRestart !== "boolean")
                return "AddonEnableAutoRestart: boolean expected";
        if (message.AddonFolderName != null && message.hasOwnProperty("AddonFolderName"))
            if (!$util.isString(message.AddonFolderName))
                return "AddonFolderName: string expected";
        return null;
    };

    /**
     * Creates an AddonManifest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof AddonManifest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {AddonManifest} AddonManifest
     */
    AddonManifest.fromObject = function fromObject(object) {
        if (object instanceof $root.AddonManifest)
            return object;
        let message = new $root.AddonManifest();
        if (object.AddonName != null)
            message.AddonName = String(object.AddonName);
        if (object.AddonDescription != null)
            message.AddonDescription = String(object.AddonDescription);
        if (object.AddonVersion != null)
            message.AddonVersion = String(object.AddonVersion);
        if (object.AddonAuthor != null)
            message.AddonAuthor = String(object.AddonAuthor);
        if (object.AddonWebsite != null)
            message.AddonWebsite = String(object.AddonWebsite);
        if (object.AddonIcon != null)
            message.AddonIcon = String(object.AddonIcon);
        if (object.AddonClientID != null)
            message.AddonClientID = String(object.AddonClientID);
        if (object.AddonBootstrapEntryPoint != null)
            message.AddonBootstrapEntryPoint = String(object.AddonBootstrapEntryPoint);
        if (object.AddonEnableAutoRestart != null)
            message.AddonEnableAutoRestart = Boolean(object.AddonEnableAutoRestart);
        if (object.AddonFolderName != null)
            message.AddonFolderName = String(object.AddonFolderName);
        return message;
    };

    /**
     * Creates a plain object from an AddonManifest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof AddonManifest
     * @static
     * @param {AddonManifest} message AddonManifest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AddonManifest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.AddonName = "";
            object.AddonDescription = "";
            object.AddonVersion = "";
            object.AddonAuthor = "";
            object.AddonWebsite = "";
            object.AddonIcon = "";
            object.AddonClientID = "";
            object.AddonBootstrapEntryPoint = "";
            object.AddonEnableAutoRestart = false;
            object.AddonFolderName = "";
        }
        if (message.AddonName != null && message.hasOwnProperty("AddonName"))
            object.AddonName = message.AddonName;
        if (message.AddonDescription != null && message.hasOwnProperty("AddonDescription"))
            object.AddonDescription = message.AddonDescription;
        if (message.AddonVersion != null && message.hasOwnProperty("AddonVersion"))
            object.AddonVersion = message.AddonVersion;
        if (message.AddonAuthor != null && message.hasOwnProperty("AddonAuthor"))
            object.AddonAuthor = message.AddonAuthor;
        if (message.AddonWebsite != null && message.hasOwnProperty("AddonWebsite"))
            object.AddonWebsite = message.AddonWebsite;
        if (message.AddonIcon != null && message.hasOwnProperty("AddonIcon"))
            object.AddonIcon = message.AddonIcon;
        if (message.AddonClientID != null && message.hasOwnProperty("AddonClientID"))
            object.AddonClientID = message.AddonClientID;
        if (message.AddonBootstrapEntryPoint != null && message.hasOwnProperty("AddonBootstrapEntryPoint"))
            object.AddonBootstrapEntryPoint = message.AddonBootstrapEntryPoint;
        if (message.AddonEnableAutoRestart != null && message.hasOwnProperty("AddonEnableAutoRestart"))
            object.AddonEnableAutoRestart = message.AddonEnableAutoRestart;
        if (message.AddonFolderName != null && message.hasOwnProperty("AddonFolderName"))
            object.AddonFolderName = message.AddonFolderName;
        return object;
    };

    /**
     * Converts this AddonManifest to JSON.
     * @function toJSON
     * @memberof AddonManifest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AddonManifest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for AddonManifest
     * @function getTypeUrl
     * @memberof AddonManifest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    AddonManifest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/AddonManifest";
    };

    return AddonManifest;
})();

export { $root as default };
